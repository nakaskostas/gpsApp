<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Route Planner – Uphill Red Only (FIXED)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Leaflet -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>

    <style>
        .leaflet-container{height:100%;width:100%;cursor:crosshair}
        .pin-icon{background:#3B82F6;border:3px solid #fff;border-radius:50%;width:32px;height:32px;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:bold;font-size:14px;box-shadow:0 3px 8px rgba(0,0,0,.4)}
        .pin-icon.start{background:#10B981}
        .pin-icon.selected{border-color:#FFC107;border-width:4px}
        .loading-spinner{border:3px solid #f3f3f3;border-top:3px solid #3B82F6;border-radius:50%;width:20px;height:20px;animation:spin 1s linear infinite}
        @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
        .error-fade{animation:fadeOut 5s forwards}
        @keyframes fadeOut{0%{opacity:1}80%{opacity:1}100%{opacity:0;display:none}}
    </style>
</head>

<body class="bg-gray-100 h-screen overflow-hidden">
    <!-- Header -->
    <div class="bg-white shadow-sm p-4 flex justify-between items-center z-50">
        <h1 class="text-xl font-bold flex items-center gap-2">
            <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
            </svg>
            Route Planner – Uphill Red Only (FIXED)
        </h1>
        <div class="flex gap-2">
            <button id="clearRoute" class="flex items-center gap-2 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
                Clear
            </button>
            <button id="downloadGPX" class="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors" style="display:none">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                </svg>
                GPX
            </button>
        </div>
    </div>

    <!-- Messages -->
    <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 mx-4 mt-2 rounded relative z-40" style="display:none"><span id="errorText"></span></div>
    <div id="loadingMessage" class="fixed top-20 left-1/2 -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded shadow-lg z-50 flex items-center gap-2" style="display:none"><div class="loading-spinner"></div><span>Calculating...</span></div>

    <!-- Map -->
    <div class="relative" style="height:calc(100vh - 280px)">
        <div id="map" class="h-full w-full"></div>
        <div id="instructions" class="absolute bottom-4 left-1/2 -translate-x-1/2 bg-blue-50 border border-blue-200 px-4 py-2 rounded shadow-lg z-30">
            <p class="text-blue-700 text-sm">Click map to add pins. Right-click near a pin to remove it.</p>
        </div>
    </div>

    <!-- Stats & Chart -->
    <div id="elevationSection" class="bg-white border-t" style="height:200px;display:none">
        <div id="routeStats" class="p-4 border-b">
            <h3 class="text-lg font-semibold mb-3">Route Statistics</h3>
            <div class="grid grid-cols-3 gap-4 text-sm">
                <div class="text-center"><div class="text-gray-600 text-xs">Distance</div><div id="totalDistance" class="font-bold text-lg text-blue-600">–</div></div>
                <div class="text-center"><div class="text-gray-600 text-xs">Elevation Gain</div><div id="elevationGain" class="font-bold text-lg text-green-600">–</div></div>
                <div class="text-center"><div class="text-gray-600 text-xs">Elevation Loss</div><div id="elevationLoss" class="font-bold text-lg text-red-600">–</div></div>
            </div>
        </div>
        <div class="p-4 h-[120px]">
            <div id="elevationChartContainer" class="h-full relative">
                <canvas id="elevationChart"></canvas>
                <div id="noElevationMessage" class="flex items-center justify-center h-full text-gray-500 text-sm">Create a route to see elevation profile</div>
            </div>
        </div>
    </div>

    <script>
        // ---------- CONFIG ----------
        const CONFIG = {
            OPENROUTE_API_KEY:'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImY5MTc5YjI0YTE2NDQ1ZDg4YjgxMzlmZjAxY2MzNDYzIiwiaCI6Im11cm11cjY0In0=',
            ELEVATION_API_URL:'https://api.open-elevation.com/api/v1/lookup',
            GRAPHHOPPER_KEY:'bf786448-12b8-4aea-8549-b3cc120e9f8c',
            MAX_PINS:20,
            DEFAULT_CENTER:[37.9755,23.7348],
            DEFAULT_ZOOM:13,
            STEEP_GRADIENT_THRESHOLD: 6   // ← increased + smooth filter
        };
        const state={map:null,pins:[],markers:[],routePolyline:null,elevationChart:null,currentRoute:null,selectedMarkerIndex:-1};

        // ---------- INIT ----------
        function initApp(){
            initMap();
            setupEvents();
            console.log('App ready');
        }
        function initMap(){
            state.map=L.map('map',{center:CONFIG.DEFAULT_CENTER,zoom:CONFIG.DEFAULT_ZOOM});
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'© OSM'}).addTo(state.map);
            state.map.on('click',handleClick);
            state.map.on('contextmenu',handleRightClick);
            navigator.geolocation?.getCurrentPosition(p=>state.map.setView([p.coords.latitude,p.coords.longitude],CONFIG.DEFAULT_ZOOM),()=>{},{timeout:5e3});
        }
        function setupEvents(){
            document.getElementById('clearRoute').addEventListener('click',()=>clearRoute());
            document.getElementById('downloadGPX').addEventListener('click',downloadGPX);
        }

        // ---------- MAP ----------
        function handleClick(e){
            if(state.pins.length>=CONFIG.MAX_PINS){showError(`Max ${CONFIG.MAX_PINS} pins`);return}
            state.pins.push(e.latlng);
            addMarker(e.latlng,state.pins.length,state.pins.length===1);
            if(state.pins.length>=2)calcRoute();
            updateInstr();
        }
        function handleRightClick(e){
            e.originalEvent.preventDefault();
            let closest=-1,min=Infinity;
            state.pins.forEach((p,i)=>{
                const d=e.latlng.distanceTo(p);
                if(d<min&&d<100){min=d;closest=i}
            });
            if(closest!==-1)removePin(closest);
        }
        function addMarker(ll,n,start){
            const m=L.marker(ll,{icon:createIcon(n,start),draggable:true}).addTo(state.map);
            m.on('dragend',e=>{const i=state.markers.indexOf(m);state.pins[i]=e.target.getLatLng();if(state.pins.length>=2)calcRoute();});
            m.on('click',e=>{select(state.markers.indexOf(m));e.originalEvent.stopPropagation();});
            state.markers.push(m);
        }
        function createIcon(n,start,sel=false){
            const cls='pin-icon'+(start?' start':'')+(sel?' selected':'');
            return L.divIcon({className:cls,html:n,iconSize:[32,32],iconAnchor:[16,16]});
        }
        function select(i){
            if(state.selectedMarkerIndex>=0){const m=state.markers[state.selectedMarkerIndex];m.setIcon(createIcon(state.selectedMarkerIndex+1,state.selectedMarkerIndex===0));}
            state.selectedMarkerIndex=(i===state.selectedMarkerIndex)?-1:i;
            if(state.selectedMarkerIndex>=0){state.markers[i].setIcon(createIcon(i+1,i===0,true));}
        }
        function removePin(i){
            state.map.removeLayer(state.markers[i]);
            state.pins.splice(i,1);state.markers.splice(i,1);
            state.markers.forEach((m,j)=>m.setIcon(createIcon(j+1,j===0)));
            state.selectedMarkerIndex=-1;
            if(state.pins.length>=2)calcRoute();else clearRoute(false);
            updateInstr();
        }

        // ---------- ROUTING ----------
        async function calcRoute(){
            if(state.pins.length<2)return;
            showLoad(true);hideError();
            try{
                let route=null;
                const apis=[{name:'ORS',fn:getORS},{name:'GH',fn:getGH},{name:'OSRM',fn:getOSRM}];
                for(const a of apis){try{route=await a.fn();break}catch(e){console.warn(a.name,e.message)}}
                if(!route)throw new Error('All routers failed');
                state.currentRoute=route;
                drawRoute(route);await addElevation(route);
            }catch(e){showError('Route failed');console.error(e)}finally{showLoad(false)}
        }
        async function getORS(){
            const coords=state.pins.map(p=>[p.lng,p.lat]);
            const res=await fetch('https://api.openrouteservice.org/v2/directions/driving-car/geojson',{method:'POST',headers:{Authorization:CONFIG.OPENROUTE_API_KEY,'Content-Type':'application/json'},body:JSON.stringify({coordinates:coords,instructions:false,elevation:false})});
            if(!res.ok)throw new Error(res.status);
            const j=await res.json();const f=j.features?.[0];
            return{coordinates:f.geometry.coordinates.map(c=>[c[1],c[0]]),distance:f.properties.summary?.distance||0};
        }
        async function getGH(){
            const pts=state.pins.map(p=>`point=${p.lat},${p.lng}`).join('&');
            const res=await fetch(`https://graphhopper.com/api/1/route?${pts}&vehicle=car&calc_points=true&type=json&key=${CONFIG.GRAPHHOPPER_KEY}`);
            if(!res.ok)throw new Error(res.status);
            const j=await res.json();const p=j.paths?.[0];
            return{coordinates:polyDecode(p.points),distance:p.distance};
        }
        async function getOSRM(){
            const coords=state.pins.map(p=>`${p.lng},${p.lat}`).join(';');
            const res=await fetch(`https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`);
            if(!res.ok)throw new Error(res.status);
            const j=await res.json();const r=j.routes?.[0];
            return{coordinates:r.geometry.coordinates.map(c=>[c[1],c[0]]),distance:r.distance};
        }
        function polyDecode(str,p=5){
            let i=0,lat=0,lng=0,out=[],f=10**p;
            while(i<str.length){
                let b,sh=0,res=0;
                do{b=str.charCodeAt(i++)-63;res|=(b&0x1f)<<sh;sh+=5}while(b>=0x20);
                const dLat=(res&1)?~(res>>1):(res>>1);lat+=dLat;
                sh=0;res=0;
                do{b=str.charCodeAt(i++)-63;res|=(b&0x1f)<<sh;sh+=5}while(b>=0x20);
                const dLng=(res&1)?~(res>>1):(res>>1);lng+=dLng;
                out.push([lat/f,lng/f]);
            }
            return out;
        }
        function drawRoute(route){
            if(state.routePolyline){if(Array.isArray(state.routePolyline))state.routePolyline.forEach(l=>state.map.removeLayer(l));else state.map.removeLayer(state.routePolyline);}
            state.routePolyline=L.polyline(route.coordinates,{color:'#3B82F6',weight:4,opacity:.8}).addTo(state.map);
            state.map.fitBounds(L.featureGroup([state.routePolyline,...state.markers]).getBounds(),{padding:[20,20]});
            document.getElementById('downloadGPX').style.display='flex';
            updateStats({distance:route.distance});
        }

        // ---------- ELEVATION ----------
        async function addElevation(route){
            try{
                const maxPts=50,step=Math.max(1,Math.floor(route.coordinates.length/maxPts)),sample=route.coordinates.filter((_,i)=>i%step===0);
                if(sample.at(-1)!==route.coordinates.at(-1))sample.push(route.coordinates.at(-1));
                const ctl=new AbortController(),to=setTimeout(()=>ctl.abort(),10e3);
                const res=await fetch(CONFIG.ELEVATION_API_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({locations:sample.map(c=>({latitude:c[0],longitude:c[1]}))}),signal:ctl.signal});
                clearTimeout(to);
                if(!res.ok)throw new Error(res.status);
                const j=await res.json();
                processElev(j.results||[],sample,route);
            }catch{mockElev(route)}
        }
        function mockElev(route){
            const pts=20,step=Math.max(1,Math.floor(route.coordinates.length/pts)),sample=route.coordinates.filter((_,i)=>i%step===0);
            const mock=sample.map((_,i)=>({elevation:100+Math.sin(i*.3)*80+Math.cos(i*.1)*40+(Math.random()-.5)*20}));
            processElev(mock,sample,route);
        }
        function processElev(elev,coords,route){
            let dist=0,data=[];
            elev.forEach((p,i)=>{
                if(i){dist+=distHaversine(coords[i-1],coords[i]);}
                let grad=0;
                if(i){
                    const diff=p.elevation-(elev[i-1]?.elevation||p.elevation);
                    const dDist=dist-(data[i-1]?.distance||0);
                    if(dDist>0)grad=Math.atan(diff/dDist)*180/Math.PI;
                }
                data.push({distance:dist,elevation:p.elevation,gradient:grad});
            });
            updateStats({distance:route.distance,elevationData:data});
            drawColored(route,data,coords);
            showElev(true);
        }
        function drawColored(route,elevData,elevCoords){
            if(state.routePolyline){if(Array.isArray(state.routePolyline))state.routePolyline.forEach(l=>state.map.removeLayer(l));else state.map.removeLayer(state.routePolyline);}
            const elevIdx=[],polylines=[],segments=[],colors=[];
            elevCoords.forEach(ec=>{
                let min=Infinity,idx=0;
                route.coordinates.forEach((rc,i)=>{
                    const d=Math.abs(rc[0]-ec[0])+Math.abs(rc[1]-ec[1]);
                    if(d<min){min=d;idx=i;}
                });
                elevIdx.push(idx);
            });
            // smoothing window 5 points
            const smoothWindow=5;
            for(let i=0;i<route.coordinates.length;i++){
                let isSteep=false;
                for(let j=0;j<elevIdx.length-1;j++){
                    if(i>=elevIdx[j]&&i<=elevIdx[j+1]){
                        let sum=0,cnt=0;
                        for(let k=-Math.floor(smoothWindow/2);k<=Math.floor(smoothWindow/2);k++){
                            const idx=j+k;
                            if(idx>=0&&idx<elevData.length){sum+=elevData[idx].gradient;cnt++;}
                        }
                        const smoothGrad=sum/cnt;
                        isSteep = Math.max(0, smoothGrad) > CONFIG.STEEP_GRADIENT_THRESHOLD;
                        break;
                    }
                }
                segments.push(route.coordinates[i]);
                colors.push(isSteep?'#EF4444':'#3B82F6');
            }
            let start=0;
            for(let i=1;i<segments.length;i++){
                if(colors[i]!==colors[i-1]||i===segments.length-1){
                    polylines.push(L.polyline(segments.slice(start,i+1),{color:colors[i-1],weight:4,opacity:.8}).addTo(state.map));
                    start=i;
                }
            }
            state.routePolyline=polylines;
            state.map.fitBounds(L.featureGroup([...polylines,...state.markers]).getBounds(),{padding:[20,20]});
            drawChart(data);
        }
        function distHaversine(a,b){
            const R=6371e3,φ1=a[0]*Math.PI/180,φ2=b[0]*Math.PI/180,Δφ=(b[0]-a[0])*Math.PI/180,Δλ=(b[1]-a[1])*Math.PI/180;
            const h=Math.sin(Δφ/2)**2+Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
            return R*2*Math.atan2(Math.sqrt(h),Math.sqrt(1-h));
        }

        // ---------- CHART / STATS ----------
        function updateStats({distance,elevationData}){
            document.getElementById('totalDistance').textContent=distance>1000?`${(distance/1000).toFixed(1)} km`:`${Math.round(distance)} m`;
            if(!elevationData?.length){document.getElementById('elevationGain').textContent='-';document.getElementById('elevationLoss').textContent='-';return;}
            let gain=0,loss=0;
            for(let i=1;i<elevationData.length;i++){
                const diff=elevationData[i].elevation-elevationData[i-1].elevation;
                diff>0?gain+=diff:loss-=diff;
            }
            document.getElementById('elevationGain').textContent=`+${Math.round(gain)} m`;
            document.getElementById('elevationLoss').textContent=`-${Math.round(loss)} m`;
        }
        function drawChart(data){
            const ctx=document.getElementById('elevationChart').getContext('2d');
            if(state.elevationChart)state.elevationChart.destroy();
            state.elevationChart=new Chart(ctx,{
                type:'line',
                data:{
                    labels:data.map(d=>d.distance>1000?(d.distance/1000).toFixed(1):Math.round(d.distance)),
                    datasets:[{label:'Elevation (m)',data:data.map(d=>d.elevation),borderColor:'#3B82F6',backgroundColor:'rgba(59,130,246,.1)',borderWidth:2,fill:true,tension:.1}]
                },
                options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{display:false}},scales:{x:{title:{text:'Distance (km)'}},y:{title:{text:'Elevation (m)'}}}}
            });
        }
        function showElev(show){document.getElementById('elevationSection').style.display=show?'block':'none'}

        // ---------- UTILS ----------
        function clearRoute(clearPins=true){
            if(clearPins){state.markers.forEach(m=>state.map.removeLayer(m));state.markers=[];state.pins=[];state.selectedMarkerIndex=-1;}
            if(state.routePolyline){if(Array.isArray(state.routePolyline))state.routePolyline.forEach(l=>state.map.removeLayer(l));else state.map.removeLayer(state.routePolyline);state.routePolyline=null;}
            if(state.elevationChart){state.elevationChart.destroy();state.elevationChart=null;}
            state.currentRoute=null;showElev(false);document.getElementById('downloadGPX').style.display='none';updateInstr();hideError();
        }
        function downloadGPX(){
            if(!state.currentRoute){showError('No route');return}
            const gpx=`<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1" creator="RoutePlanner" xmlns="http://www.topografix.com/GPX/1/1"><metadata><name>Route</name><time>${new Date().toISOString()}</time></metadata><trk><trkseg>${state.currentRoute.coordinates.map(c=>`<trkpt lat="${c[0]}" lon="${c[1]}"/>`).join('')}</trkseg></trk>${state.pins.map((p,i)=>`<wpt lat="${p.lat}" lon="${p.lng}"><name>${i?'WP'+i:'Start'}</name></wpt>`).join('')}</gpx>`;
            const blob=new Blob([gpx],{type:'application/gpx+xml'}),url=URL.createObjectURL(blob);
            const a=document.createElement('a');a.href=url;a.download=`route_${new Date().toISOString().split('T')[0]}.gpx`;document.body.appendChild(a);a.click();document.body.removeChild(a);URL.revokeObjectURL(url);
        }
        function showLoad(on){document.getElementById('loadingMessage').style.display=on?'flex':'none'}
        function showError(msg){
            const el=document.getElementById('errorMessage'),txt=document.getElementById('errorText');
            txt.textContent=msg;el.style.display='block';el.classList.remove('error-fade');setTimeout(()=>{el.classList.add('error-fade');setTimeout(hideError,1000)},4000);
        }
        function hideError(){document.getElementById('errorMessage').style.display='none';document.getElementById('errorMessage').className='bg-red-100 border border-red-400 text-red-700 px-4 py-3 mx-4 mt-2 rounded relative z-40'}
        function updateInstr(){document.getElementById('instructions').style.display=state.pins.length===0?'block':'none'}

        document.addEventListener('DOMContentLoaded',initApp);
        window.addEventListener('resize',()=>state.map?.invalidateSize());
        document.addEventListener('contextmenu',e=>{if(e.target.closest('#map'))e.preventDefault()});
    </script>
</body>
</html>