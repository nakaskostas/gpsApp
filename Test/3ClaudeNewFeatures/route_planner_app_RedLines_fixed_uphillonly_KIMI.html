<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Planner – Uphill Red Only</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"/>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <style>
        .leaflet-container{height:100%;width:100%;cursor:crosshair}
        .pin-icon{background:#3B82F6;border:3px solid #fff;border-radius:50%;width:32px;height:32px;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:bold;font-size:14px;box-shadow:0 3px 8px rgba(0,0,0,.4)}
        .pin-icon.start{background:#10B981}
        .pin-icon.selected{border-color:#FFC107;border-width:4px}
        .loading-spinner{border:3px solid #f3f3f3;border-top:3px solid #3B82F6;border-radius:50%;width:20px;height:20px;animation:spin 1s linear infinite}
        @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
        .error-fade{animation:fadeOut 5s forwards}
        @keyframes fadeOut{0%{opacity:1}80%{opacity:1}100%{opacity:0;display:none}}
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden">
    <!-- Header -->
    <div class="bg-white shadow-sm p-4 flex justify-between items-center relative z-50">
        <h1 class="text-xl font-bold flex items-center gap-2">
            <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
            </svg>
            Route Planner – Uphill Red Only
        </h1>
        <div class="flex gap-2">
            <button id="clearRoute" class="flex items-center gap-2 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
                Clear Route
            </button>
            <button id="downloadGPX" class="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors" style="display:none">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                </svg>
                Download GPX
            </button>
        </div>
    </div>

    <!-- Error / Loading -->
    <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 mx-4 mt-2 rounded relative z-40" style="display:none"><span id="errorText"></span></div>
    <div id="loadingMessage" class="fixed top-20 left-1/2 transform -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded shadow-lg z-50 flex items-center gap-2" style="display:none"><div class="loading-spinner"></div><span>Calculating route...</span></div>

    <!-- Map -->
    <div class="relative" style="height:calc(100vh - 280px)">
        <div id="map" class="h-full w-full"></div>
        <div id="instructions" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-blue-50 border border-blue-200 px-4 py-2 rounded shadow-lg z-30">
            <p class="text-blue-700 text-sm">Click on the map to place pins and create your route. Right-click to remove pins.</p>
        </div>
    </div>

    <!-- Stats & Chart -->
    <div id="elevationSection" class="bg-white border-t" style="height:200px;display:none">
        <div id="routeStats" class="p-4 border-b">
            <h3 class="text-lg font-semibold mb-3">Route Statistics</h3>
            <div class="grid grid-cols-3 gap-4 text-sm">
                <div class="text-center">
                    <div class="text-gray-600 text-xs uppercase tracking-wide">Distance</div>
                    <div id="totalDistance" class="font-bold text-lg text-blue-600">Click on map to start</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-600 text-xs uppercase tracking-wide">Elevation Gain</div>
                    <div id="elevationGain" class="font-bold text-lg text-green-600">-</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-600 text-xs uppercase tracking-wide">Elevation Loss</div>
                    <div id="elevationLoss" class="font-bold text-lg text-red-600">-</div>
                </div>
            </div>
        </div>
        <div class="p-4" style="height:120px">
            <div id="elevationChartContainer" style="height:100%;position:relative">
                <canvas id="elevationChart"></canvas>
                <div id="noElevationMessage" class="flex items-center justify-center h-full text-gray-500 text-sm">Create a route to see elevation profile</div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // --- CONFIG & STATE ---
        const CONFIG = {
            OPENROUTE_API_KEY:'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImY5MTc5YjI0YTE2NDQ1ZDg4YjgxMzlmZjAxY2MzNDYzIiwiaCI6Im11cm11cjY0In0=',
            ELEVATION_API_URL:'https://api.open-elevation.com/api/v1/lookup',
            GRAPHHOPPER_KEY:'bf786448-12b8-4aea-8549-b3cc120e9f8c',
            MAX_PINS:20,
            DEFAULT_CENTER:[37.9755,23.7348],
            DEFAULT_ZOOM:13,
            STEEP_GRADIENT_THRESHOLD:5
        };
        const state={map:null,pins:[],markers:[],routePolyline:null,elevationChart:null,currentRoute:null,selectedMarkerIndex:-1};

        // --- INIT ---
        function initApp(){
            initMap();
            setupEventListeners();
            console.log('Route Planner initialized');
        }
        function initMap(){
            state.map=L.map('map',{center:CONFIG.DEFAULT_CENTER,zoom:CONFIG.DEFAULT_ZOOM,zoomControl:true});
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'© OpenStreetMap contributors'}).addTo(state.map);
            state.map.on('click',handleMapClick);
            state.map.on('contextmenu',handleMapRightClick);
            navigator.geolocation?.getCurrentPosition(p=>state.map.setView([p.coords.latitude,p.coords.longitude],CONFIG.DEFAULT_ZOOM),()=>{},{timeout:5000});
        }
        function setupEventListeners(){
            document.getElementById('clearRoute').addEventListener('click',()=>clearRoute());
            document.getElementById('downloadGPX').addEventListener('click',downloadGPX);
        }

        // --- MAP INTERACTION ---
        function handleMapClick(e){
            if(state.pins.length>=CONFIG.MAX_PINS){showError(`Maximum ${CONFIG.MAX_PINS} pins allowed`);return}
            state.pins.push(e.latlng);
            addMarker(e.latlng,state.pins.length,state.pins.length===1);
            if(state.pins.length>=2)calculateRoute();
            updateInstructions();
        }
        function handleMapRightClick(e){
            e.originalEvent.preventDefault();
            let closest=-1, min=Infinity;
            state.pins.forEach((p,i)=>{
                const d=e.latlng.distanceTo(p);
                if(d<min&&d<100){min=d;closest=i}
            });
            if(closest!==-1)removePin(closest);
        }
        function createNumberedIcon(n,start=false,selected=false){
            const cls='pin-icon'+(start?' start':'')+(selected?' selected':'');
            return L.divIcon({className:cls,html:n.toString(),iconSize:[32,32],iconAnchor:[16,16],popupAnchor:[0,-16]});
        }
        function addMarker(latlng,n,start=false){
            const m=L.marker(latlng,{icon:createNumberedIcon(n,start),draggable:true}).addTo(state.map);
            m.on('dragend',e=>{
                const i=state.markers.indexOf(m);
                state.pins[i]=e.target.getLatLng();
                if(state.pins.length>=2)calculateRoute();
            });
            m.on('click',e=>{selectMarker(state.markers.indexOf(m));e.originalEvent.stopPropagation()});
            state.markers.push(m);
        }
        function selectMarker(i){
            if(state.selectedMarkerIndex>=0){
                const prev=state.markers[state.selectedMarkerIndex];
                prev.setIcon(createNumberedIcon(state.selectedMarkerIndex+1,state.selectedMarkerIndex===0,false));
            }
            if(i!==state.selectedMarkerIndex){
                state.selectedMarkerIndex=i;
                state.markers[i].setIcon(createNumberedIcon(i+1,i===0,true));
            }else{state.selectedMarkerIndex=-1}
        }
        function removePin(i){
            if(i<0||i>=state.pins.length)return;
            state.map.removeLayer(state.markers[i]);
            state.pins.splice(i,1);state.markers.splice(i,1);
            state.markers.forEach((m,j)=>m.setIcon(createNumberedIcon(j+1,j===0,false)));
            state.selectedMarkerIndex=-1;
            if(state.pins.length>=2)calculateRoute();else clearRoute(false);
            updateInstructions();
        }

        // --- ROUTING ---
        async function calculateRoute(){
            if(state.pins.length<2)return;
            showLoading(true);hideError();
            try{
                console.log('Calculating route for',state.pins.length,'pins');
                let route=null;
                const apis=[{name:'OpenRouteService',fn:calculateRouteOpenRoute},{name:'GraphHopper',fn:calculateRouteGraphHopper},{name:'OSRM',fn:calculateRouteOSRM}];
                for(const api of apis){try{route=await api.fn();break}catch(e){console.log(api.name,'failed:',e.message)}}
                if(!route)throw new Error('All routing services failed');
                state.currentRoute=route;displayRoute(route);await calculateElevation(route);
            }catch(e){showError('Failed to calculate route');console.error(e)}finally{showLoading(false)}
        }
        async function calculateRouteOpenRoute(){
            const coords=state.pins.map(p=>[p.lng,p.lat]);
            const r=await fetch('https://api.openrouteservice.org/v2/directions/driving-car/geojson',{
                method:'POST',headers:{Authorization:CONFIG.OPENROUTE_API_KEY,'Content-Type':'application/json'},
                body:JSON.stringify({coordinates:coords,instructions:false,elevation:false})
            });
            if(!r.ok)throw new Error('ORS '+r.status);
            const d=await r.json();if(!d.features?.[0])throw new Error('No route');
            return{coordinates:d.features[0].geometry.coordinates.map(c=>[c[1],c[0]]),distance:d.features[0].properties.summary?.distance||0};
        }
        async function calculateRouteGraphHopper(){
            const pts=state.pins.map(p=>`point=${p.lat},${p.lng}`).join('&');
            const r=await fetch(`https://graphhopper.com/api/1/route?${pts}&vehicle=car&calc_points=true&type=json&key=${CONFIG.GRAPHHOPPER_KEY}`);
            if(!r.ok)throw new Error('GH '+r.status);
            const d=await r.json();if(!d.paths?.[0])throw new Error('No route');
            return{coordinates:decodePolyline(d.paths[0].points),distance:d.paths[0].distance};
        }
        async function calculateRouteOSRM(){
            const coords=state.pins.map(p=>`${p.lng},${p.lat}`).join(';');
            const r=await fetch(`https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`);
            if(!r.ok)throw new Error('OSRM '+r.status);
            const d=await r.json();if(!d.routes?.[0])throw new Error('No route');
            return{coordinates:d.routes[0].geometry.coordinates.map(c=>[c[1],c[0]]),distance:d.routes[0].distance};
        }
        function decodePolyline(str,p=5){
            let i=0,lat=0,lng=0,out=[],f=Math.pow(10,p);
            while(i<str.length){
                let b,sh=0,res=0;
                do{b=str.charCodeAt(i++)-63;res|=(b&0x1f)<<sh;sh+=5}while(b>=0x20);
                const dLat=((res&1)?~(res>>1):(res>>1));lat+=dLat;
                sh=0;res=0;
                do{b=str.charCodeAt(i++)-63;res|=(b&0x1f)<<sh;sh+=5}while(b>=0x20);
                const dLng=((res&1)?~(res>>1):(res>>1));lng+=dLng;
                out.push([lat/f,lng/f]);
            }
            return out;
        }
        function displayRoute(route){
            if(state.routePolyline){
                if(Array.isArray(state.routePolyline))state.routePolyline.forEach(p=>state.map.removeLayer(p));else state.map.removeLayer(state.routePolyline);
            }
            state.routePolyline=L.polyline(route.coordinates,{color:'#3B82F6',weight:4,opacity:.8}).addTo(state.map);
            const g=new L.featureGroup([state.routePolyline,...state.markers]);state.map.fitBounds(g.getBounds(),{padding:[20,20]});
            document.getElementById('downloadGPX').style.display='flex';
            updateRouteStats({distance:route.distance});
        }

        // --- ELEVATION ---
        async function calculateElevation(route){
            try{
                const max=50,step=Math.max(1,Math.floor(route.coordinates.length/max)),sample=route.coordinates.filter((_,i)=>i%step===0);
                if(sample[sample.length-1]!==route.coordinates[route.coordinates.length-1])sample.push(route.coordinates[route.coordinates.length-1]);
                const ctl=new AbortController(),to=setTimeout(()=>ctl.abort(),10000);
                const r=await fetch(CONFIG.ELEVATION_API_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({locations:sample.map(c=>({latitude:c[0],longitude:c[1]}))}),signal:ctl.signal});
                clearTimeout(to);
                if(!r.ok)throw new Error('Elevation API '+r.status);
                const d=await r.json();
                if(d.results?.length)processElevationData(d.results,sample,route);else throw new Error('No data');
            }catch(e){createMockElevationData(route)}
        }
        function createMockElevationData(route){
            const pts=20,step=Math.max(1,Math.floor(route.coordinates.length/pts)),sample=route.coordinates.filter((_,i)=>i%step===0);
            const mock=sample.map((_,i)=>{
                const base=100,variation=Math.sin(i*.3)*80+Math.cos(i*.1)*40,noise=(Math.random()-.5)*20;
                return{elevation:Math.max(0,base+variation+noise)};
            });
            processElevationData(mock,sample,route);
        }
        function processElevationData(elev,coords,route){
            let dist=0,data=[];
            elev.forEach((p,i)=>{
                if(i>0){
                    const prev=coords[i-1],curr=coords[i];
                    dist+=calculateDistance(prev[0],prev[1],curr[0],curr[1]);
                }
                let grad=0;
                if(i>0){
                    const diff=p.elevation-elev[i-1].elevation,distDiff=dist-(data[i-1]?.distance||0);
                    if(distDiff>0)grad=Math.atan(diff/distDiff)*180/Math.PI;
                }
                data.push({distance:dist,elevation:p.elevation,gradient:grad});
            });
            updateRouteStats({distance:route.distance,elevationData:data});
            displayElevationChart(data);
            displayColoredRoute(route,data,coords);
            showElevationSection(true);
        }
        function displayColoredRoute(route,elevData,elevCoords){
            if(state.routePolyline){
                if(Array.isArray(state.routePolyline))state.routePolyline.forEach(p=>state.map.removeLayer(p));else state.map.removeLayer(state.routePolyline);
            }
            const elevIndices=[];
            elevCoords.forEach(ec=>{
                let min=Infinity,idx=0;
                route.coordinates.forEach((rc,i)=>{
                    const d=Math.abs(rc[0]-ec[0])+Math.abs(rc[1]-ec[1]);
                    if(d<min){min=d;idx=i}
                });
                elevIndices.push(idx);
            });
            const polylines=[],segments=[],colors=[];
            for(let i=0;i<route.coordinates.length;i++){
                const coord=route.coordinates[i];
                let isSteep=false;
                for(let j=0;j<elevIndices.length-1;j++){
                    if(i>=elevIndices[j]&&i<=elevIndices[j+1]){
                        const seg=elevData[j];
                        // ****** ONLY UPHILL >5° ******
                        isSteep = seg && Math.max(0, seg.gradient) > CONFIG.STEEP_GRADIENT_THRESHOLD;
                        break;
                    }
                }
                segments.push(coord);
                colors.push(isSteep?'#EF4444':'#3B82F6');
            }
            let start=0;
            for(let i=1;i<segments.length;i++){
                if(colors[i]!==colors[i-1]||i===segments.length-1){
                    const p=L.polyline(segments.slice(start,i+1),{color:colors[i-1],weight:4,opacity:.8}).addTo(state.map);
                    polylines.push(p);
                    start=i;
                }
            }
            state.routePolyline=polylines;
            const g=new L.featureGroup([...polylines,...state.markers]);state.map.fitBounds(g.getBounds(),{padding:[20,20]});
            console.log(`Route displayed with ${polylines.length} colored segments`);
        }
        function calculateDistance(la1,lo1,la2,lo2){
            const R=6371e3,φ1=la1*Math.PI/180,φ2=la2*Math.PI/180,Δφ=(la2-la1)*Math.PI/180,Δλ=(lo2-lo1)*Math.PI/180;
            const a=Math.sin(Δφ/2)**2+Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
            return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
        }
        function updateRouteStats({distance,elevationData}){
            document.getElementById('totalDistance').textContent=distance>1000?`${(distance/1000).toFixed(1)} km`:`${Math.round(distance)} m`;
            if(elevationData?.length){
                let gain=0,loss=0;
                for(let i=1;i<elevationData.length;i++){
                    const diff=elevationData[i].elevation-elevationData[i-1].elevation;
                    diff>0?gain+=diff:loss-=diff;
                }
                document.getElementById('elevationGain').textContent=`+${Math.round(gain)} m`;
                document.getElementById('elevationLoss').textContent=`-${Math.round(loss)} m`;
            }else{document.getElementById('elevationGain').textContent='-';document.getElementById('elevationLoss').textContent='-'}
        }
        function displayElevationChart(data){
            const ctx=document.getElementById('elevationChart').getContext('2d');
            if(state.elevationChart)state.elevationChart.destroy();
            state.elevationChart=new Chart(ctx,{
                type:'line',
                data:{
                    labels:data.map(d=>d.distance>1000?(d.distance/1000).toFixed(1):Math.round(d.distance)),
                    datasets:[{
                        label:'Elevation (m)',data:data.map(d=>d.elevation),
                        borderColor:'#3B82F6',backgroundColor:'rgba(59,130,246,.1)',borderWidth:2,fill:true,tension:.1
                    }]
                },
                options:{responsive:true,maintainAspectRatio:false,scales:{x:{title:{text:`Distance (${data[0]?.distance>1000?'km':'m'})`}},y:{title:{text:'Elevation (m)'}}},plugins:{legend:{display:false}}}
            });
        }
        function showElevationSection(show){document.getElementById('elevationSection').style.display=show?'block':'none'}
        function clearRoute(clearPins=true){
            if(clearPins){state.markers.forEach(m=>state.map.removeLayer(m));state.markers=[];state.pins=[];state.selectedMarkerIndex=-1}
            if(state.routePolyline){
                if(Array.isArray(state.routePolyline))state.routePolyline.forEach(p=>state.map.removeLayer(p));else state.map.removeLayer(state.routePolyline);
                state.routePolyline=null;
            }
            if(state.elevationChart){state.elevationChart.destroy();state.elevationChart=null}
            state.currentRoute=null;showElevationSection(false);document.getElementById('downloadGPX').style.display='none';updateInstructions();hideError();
        }
        function downloadGPX(){
            if(!state.currentRoute){showError('No route');return}
            const gpx=generateGPX(state.currentRoute),blob=new Blob([gpx],{type:'application/gpx+xml'}),url=URL.createObjectURL(blob);
            const a=document.createElement('a');a.href=url;a.download=`route_${new Date().toISOString().split('T')[0]}.gpx`;document.body.appendChild(a);a.click();document.body.removeChild(a);URL.revokeObjectURL(url);
        }
        function generateGPX(route){
            const ts=new Date().toISOString();
            let gpx=`<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1" creator="Route Planner" xmlns="http://www.topografix.com/GPX/1/1"><metadata><name>Planned Route</name><time>${ts}</time></metadata><trk><name>Route</name><trkseg>`;
            route.coordinates.forEach(c=>gpx+=`<trkpt lat="${c[0]}" lon="${c[1]}"/>`);
            gpx+='</trkseg></trk>';
            state.pins.forEach((p,i)=>gpx+=`<wpt lat="${p.lat}" lon="${p.lng}"><name>${i?'Waypoint '+i:'Start'}</name></wpt>`);
            gpx+='</gpx>';
            return gpx;
        }
        function showLoading(show){document.getElementById('loadingMessage').style.display=show?'flex':'none'}
        function showError(msg){
            const el=document.getElementById('errorMessage'),txt=document.getElementById('errorText');
            txt.textContent=msg;el.style.display='block';setTimeout(()=>{el.classList.add('error-fade');setTimeout(hideError,1000)},4000);
        }
        function hideError(){document.getElementById('errorMessage').style.display='none';document.getElementById('errorMessage').className='bg-red-100 border border-red-400 text-red-700 px-4 py-3 mx-4 mt-2 rounded relative z-40'}
        function updateInstructions(){document.getElementById('instructions').style.display=state.pins.length===0?'block':'none'}

        document.addEventListener('DOMContentLoaded',initApp);
        window.addEventListener('resize',()=>state.map&&setTimeout(()=>state.map.invalidateSize(),100));
        document.addEventListener('contextmenu',e=>{if(e.target.closest('#map'))e.preventDefault()});
    </script>
</body>
</html>