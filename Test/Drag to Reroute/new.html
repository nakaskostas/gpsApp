<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î£Ï‡ÎµÎ´Î¹Î±ÏƒÏ„Î®Ï‚ Î”Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚ Î¼Îµ Î‘Î½Î±Î¶Î®Ï„Î·ÏƒÎ·</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LZ-String for URL compression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    
    <style>
        /* Custom styles for the application */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent body scroll */
        }
        
        #map {
            height: 100%;
            width: 100%;
            cursor: crosshair;
        }
        
        /* Styling for the pins on the map */
        .pin-icon {
            background: #3B82F6;
            border: 3px solid white;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .pin-icon.start {
            background: #10B981;
        }
        
        .pin-icon.selected {
            border-color: #F59E0B;
            border-width: 4px;
        }

        /* Loading spinner animation */
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3B82F6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        /* In-search-bar spinner */
        .search-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3B82F6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Fade out animation for messages */
        .message-fade {
            animation: fadeOut 5s forwards;
        }
        
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; display: none; }
        }

        /* Custom scrollbar for the stats panel */
        #stats-panel::-webkit-scrollbar {
            width: 8px;
        }
        #stats-panel::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        #stats-panel::-webkit-scrollbar-thumb {
            background: #a8a8a8;
            border-radius: 4px;
        }
        #stats-panel::-webkit-scrollbar-thumb:hover {
            background: #888;
        }

        /* Common button style */
        .action-button {
            background: white;
            border: none;
            border-radius: 0.5rem;
            padding: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .action-button:hover:not(:disabled) {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transform: translateY(-1px);
        }
        
        /* Menu panel styles */
        .menu-panel {
            position: absolute;
            top: 5.5rem; /* Adjusted for new button layout */
            right: 1rem;
            z-index: 2000;
            background: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            min-width: 300px;
        }
        
        .menu-hidden {
            display: none;
        }

        /* --- STYLES FOR BOTTOM PANEL --- */
        #bottomPanel {
            height: 35vh;
            background: rgba(255, 255, 255, 0.1); /* Increased transparency */
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid rgba(200, 200, 200, 0.4);
            transform: translateY(100%);
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 -4px 30px rgba(0, 0, 0, 0.1);
        }
        
        #bottomPanel.is-visible {
            transform: translateY(0);
        }

        /* Tooltip styles for estimated duration and toggles */
        .info-tooltip {
            position: absolute;
            background: #1f2937;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 300px;
            word-wrap: break-word;
            white-space: normal;
        }
        
        .info-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #1f2937 transparent transparent transparent;
        }
        
        /* Styles for search suggestions */
        #search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-top: none;
            border-radius: 0 0 0.375rem 0.375rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 2100;
            max-height: 200px;
            overflow-y: auto;
        }
        
        #search-suggestions li {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #e5e7eb;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        #search-suggestions li:last-child {
            border-bottom: none;
        }
        
        #search-suggestions li:hover, #search-suggestions li.highlighted {
            background-color: #eff6ff; /* bg-blue-50 */
        }
        
        /* Hide default clear button for search input */
        #search-input::-webkit-search-cancel-button {
            -webkit-appearance: none;
            appearance: none;
        }
        
        /* NEW: Tooltip for search results */
        .search-result-tooltip {
            position: absolute;
            background: #1f2937;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 250px;
            white-space: normal; /* Allow wrapping */
        }

        /* Drag route styles - IMPROVED FOR BETTER UX */
        .route-draggable {
            cursor: grab;
            stroke-width: 15px; /* Increased clickable area */
            stroke-opacity: 0; /* Make it transparent but wide */
            stroke: transparent;
        }
        .route-draggable:active {
            cursor: grabbing;
        }
        .ghost-waypoint {
            background: #F59E0B;
            border: 3px solid white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        /* Visible route line */
        .route-line {
            pointer-events: none; /* Allow clicks to pass through to draggable layer */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <!-- Main container for the map -->
    <div class="relative w-screen h-screen">
        <div id="map"></div>
        
        <!-- Top Right Buttons Container -->
        <div class="absolute top-4 right-4 z-[2000] flex items-center space-x-2">
            <!-- Undo Button -->
            <button id="undoButton" class="action-button disabled:opacity-50 disabled:cursor-not-allowed" title="Î‘Î½Î±Î¯ÏÎµÏƒÎ·" disabled>
                <span class="text-xl leading-none">â†¶</span>
            </button>
            
            <!-- Menu Toggle Button -->
            <button id="menuToggle" class="action-button">
                <svg id="menuIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
                <svg id="closeIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
        </div>
        
        <!-- Floating Menu Panel -->
        <div id="menuPanel" class="menu-panel menu-hidden">
             <!-- Search Bar -->
            <div class="relative mb-4">
                <input type="search" id="search-input" placeholder="Î‘Î½Î±Î¶Î®Ï„Î·ÏƒÎ· Ï„Î¿Ï€Î¿Î¸ÎµÏƒÎ¯Î±Ï‚..." class="w-full pl-3 pr-10 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                <div id="search-icon-container" class="absolute inset-y-0 right-0 flex items-center pr-3 cursor-pointer">
                    <svg id="search-magnifying-glass" class="w-5 h-5 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"></path>
                    </svg>
                    <div id="search-spinner" class="search-spinner hidden"></div>
                </div>
                 <ul id="search-suggestions" class="hidden"></ul>
            </div>

            <h1 class="text-xl font-bold mb-4 text-gray-800 flex items-center gap-2">
                <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                </svg>
                Î£Ï‡ÎµÎ´Î¹Î±ÏƒÏ„Î®Ï‚ Î”Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚
            </h1>
            <div class="flex flex-col gap-3">
                <button id="clearRoute" class="flex items-center justify-center gap-2 px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors shadow-sm">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                    </svg>
                    ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚
                </button>
                <button id="downloadGPX" class="flex items-center justify-center gap-2 px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors shadow-sm" style="display: none;">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    Î›Î®ÏˆÎ· GPX
                </button>
            </div>
            
            <!-- Round Trip Toggle -->
            <div class="mt-4 pt-4 border-t border-gray-200">
                <label for="roundTripToggle" class="flex items-center justify-between cursor-pointer">  
                    <span class="font-medium text-gray-800">ÎšÏ…ÎºÎ»Î¹ÎºÎ® Î”Î¹Î±Î´ÏÎ¿Î¼Î®</span>
                    <div class="relative">
                        <input type="checkbox" id="roundTripToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-400 peer-checked:bg-blue-600"></div>
                        <div class="absolute left-1 top-1 bg-white border-gray-300 border rounded-full h-4 w-4 transition-transform peer-checked:translate-x-full"></div>
                    </div>
                </label>
            </div>

            <!-- Steep Uphill Toggle -->
            <div class="mt-4 pt-4 border-t border-gray-200">
                <label for="steepUphillToggle" class="flex items-center justify-between cursor-pointer">
                    <span class="font-medium text-gray-800">Î‘Ï€ÏŒÏ„Î¿Î¼Î· Î±Î½Î¬Î²Î±ÏƒÎ·</span>
                    <div class="relative">
                        <input type="checkbox" id="steepUphillToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-400 peer-checked:bg-blue-600"></div>
                        <div class="absolute left-1 top-1 bg-white border-gray-300 border rounded-full h-4 w-4 transition-transform peer-checked:translate-x-full"></div>
                    </div>
                </label>
            </div>

            <!-- Share Button -->
            <div class="mt-4 pt-4 border-t border-gray-200">
                <button id="shareButton" class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 transition-colors shadow-sm disabled:bg-indigo-300 disabled:cursor-not-allowed" disabled>
                    <span class="text-xl">ğŸ“‹</span>
                    ÎšÎ¿Î¹Î½Î® Ï‡ÏÎ®ÏƒÎ·
                </button>           
            </div>
        </div>

        <!-- Top Right Loading Spinner (for general operations) -->
        <div id="topRightLoader" class="absolute top-20 right-6 z-[1999] hidden">
            <div class="bg-white p-2 rounded-full shadow-lg">
                <div class="loading-spinner"></div>
            </div>
        </div>

        <!-- Notification & Error Message Overlay -->
        <div id="messageOverlay" class="absolute top-24 left-1/2 transform -translate-x-1/2 px-4 py-3 rounded-md shadow-lg z-[4000]" style="display: none;">
            <span id="messageText"></span>
        </div>
        
        <!-- Instructions Overlay -->
        <div id="instructions" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-blue-50 border border-blue-200 px-4 py-2 rounded-lg shadow-lg z-[900]">
            <p class="text-blue-800 text-sm font-medium">
                ÎšÎ¬Î½Ï„Îµ ÎºÎ»Î¹Îº ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î· Î³Î¹Î± Î½Î± Ï€ÏÎ¿ÏƒÎ¸Î­ÏƒÎµÏ„Îµ ÏƒÎ·Î¼ÎµÎ¯Î±. Î”ÎµÎ¾Î¯ ÎºÎ»Î¹Îº Î³Î¹Î± Î±Ï†Î±Î¯ÏÎµÏƒÎ·.
            </p>
        </div>

        <!-- Button to show the bottom panel -->
        <button id="show-panel-button" class="absolute bottom-4 right-4 p-3 bg-white rounded-full shadow-lg hover:bg-gray-100 transition hidden z-[1001]" title="Î•Î¼Ï†Î¬Î½Î¹ÏƒÎ· Ï€Î¯Î½Î±ÎºÎ±">
            <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
            </svg>
        </button>
    </div>

    <!-- Bottom Section: Stats & Elevation Profile -->
    <div id="bottomPanel" class="absolute bottom-0 left-0 right-0 flex z-[1002]">
        
        <!-- Button to hide the bottom panel -->
        <button id="hide-panel-button" class="absolute top-2 right-2 p-2 rounded-full hover:bg-gray-400/30 transition-colors z-10" title="Î‘Ï€ÏŒÎºÏÏ…ÏˆÎ· Ï€Î¯Î½Î±ÎºÎ±">
            <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
        </button>

        <!-- Left Area: Route Statistics Panel -->
        <div id="stats-panel" class="w-[30%] p-4 border-r border-gray-200/50 overflow-y-auto">
            <h2 class="text-lg font-bold mb-4 text-gray-800">Î£Ï„Î±Ï„Î¹ÏƒÏ„Î¹ÎºÎ¬ Î”Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚</h2>
            <div id="stats-content" class="space-y-4">
                <!-- Stats will be populated here -->
                <div class="text-center p-3 bg-gray-50/70 rounded-lg">
                    <div class="text-gray-500 text-xs uppercase tracking-wider font-semibold">Î£Ï…Î½Î¿Î»Î¹ÎºÎ® Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·</div>
                    <div id="totalDistance" class="font-bold text-2xl text-blue-600 mt-1">--</div>
                </div>
                <!-- Estimated Duration -->
                <div class="text-center p-3 bg-gray-50/70 rounded-lg">
                    <div class="text-gray-500 text-xs uppercase tracking-wider font-semibold">Î•ÎºÏ„Î¹Î¼ÏÎ¼ÎµÎ½Î· Î”Î¹Î¬ÏÎºÎµÎ¹Î±</div>
                    <div id="estimatedDuration" class="font-bold text-2xl text-purple-600 mt-1 cursor-help">--</div>
                </div>
                <div class="text-center p-3 bg-gray-50/70 rounded-lg">
                    <div class="text-gray-500 text-xs uppercase tracking-wider font-semibold">Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ· Î‘Ï€ÏŒÏ„Î¿Î¼Î·Ï‚ Î‘Î½Î¬Î²Î±ÏƒÎ·Ï‚ (>5Â°)</div>
                    <div id="steepUphillDistance" class="font-bold text-2xl text-red-600 mt-1">--</div>
                </div>
                <div class="text-center p-3 bg-gray-50/70 rounded-lg">
                    <div class="text-gray-500 text-xs uppercase tracking-wider font-semibold">Î˜ÎµÏ„Î¹ÎºÎ® Î¥ÏˆÎ¿Î¼ÎµÏ„ÏÎ¹ÎºÎ®</div>
                    <div id="elevationGain" class="font-bold text-2xl text-green-600 mt-1">--</div>
                </div>
                <div class="text-center p-3 bg-gray-50/70 rounded-lg">
                    <div class="text-gray-500 text-xs uppercase tracking-wider font-semibold">Î‘ÏÎ½Î·Ï„Î¹ÎºÎ® Î¥ÏˆÎ¿Î¼ÎµÏ„ÏÎ¹ÎºÎ®</div>
                    <div id="elevationLoss" class="font-bold text-2xl text-orange-500 mt-1">--</div>
                </div>
            </div>
             <div id="no-stats-message" class="flex items-center justify-center h-full text-gray-500">
                Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ Î¼Î¹Î± Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î³Î¹Î± Î½Î± Î´ÎµÎ¯Ï„Îµ Ï„Î± ÏƒÏ„Î±Ï„Î¹ÏƒÏ„Î¹ÎºÎ¬.
            </div>
        </div>

        <!-- Right Area: Elevation Profile Graph -->
        <div id="elevation-panel" class="w-[70%] p-4 flex flex-col">
            <h2 class="text-lg font-bold mb-2 text-gray-800">Î¥ÏˆÎ¿Î¼ÎµÏ„ÏÎ¹ÎºÏŒ Î ÏÎ¿Ï†Î¯Î»</h2>
            <div id="elevationChartContainer" class="flex-grow relative -ml-4">
                <canvas id="elevationChart"></canvas>
                <div id="no-elevation-message" class="flex items-center justify-center h-full text-gray-500">
                    Î¤Î¿ Î³ÏÎ¬Ï†Î·Î¼Î± Î¸Î± ÎµÎ¼Ï†Î±Î½Î¹ÏƒÏ„ÎµÎ¯ ÎµÎ´Ï.
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <!-- Leaflet Polyline Decorator Plugin for arrows -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.min.js"></script>
    
    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            OPENROUTE_API_KEY: '5b3ce3597851110001cf6248f9179b24a16445d88b8139ff01cc3463',
            ELEVATION_API_URL: 'https://api.open-elevation.com/api/v1/lookup',
            GRAPHHOPPER_KEY: 'bf786448-12b8-4aea-8549-b3cc120e9f8c',
            MAX_PINS: 10, // Number of Pins
            MAX_VIA_POINTS: 3, // Max drag route via points
            DEFAULT_CENTER: [37.9838, 23.7275], // Athens, Greece
            DEFAULT_ZOOM: 13,
            STEEP_GRADIENT_THRESHOLD: 5, // degrees
            HISTORY_LIMIT: 10, // Max undo actions 
            avgFlatSpeed: 15 // average Flat Speed 
        };
        
        // --- GLOBAL STATE ---
        const state = {
            map: null,
            pins: [],
            markers: [],
            routePolylines: [],
            routeArrows: [],
            elevationChart: null,
            currentRoute: null,
            currentElevation: { data: [], coordinates: [] },
            highlightMarker: null,
            selectedMarkerIndex: -1,
            searchResultMarker: null,
            isRoundTrip: false,
            polylineDecorator: null,
            isChartJsLoaded: false,
            history: [],
            historyIndex: -1,
            showSteepHighlight: false,
            // Search state
            searchSuggestions: [],
            highlightedSuggestionIndex: -1,
            isSearchLoading: false,
            // Drag route state
            routeViaPoints: [],
            ghostWaypoint: null,
            ghostLine: null,
            isDragging: false,
            dragInsertIndex: -1,
            dragOriginalRoute: null,
            draggingPolyline: null,
            dragStartLatLng: null,
            dragSegmentIndex: -1
        };

        // --- UI ELEMENTS & SHARED VARIABLES ---
        let bottomPanel, hidePanelButton, showPanelButton;

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', initApp);

        function initApp() {
            initMap();
            initUIElements();
            setupEventListeners();
            
            if (!parseUrlAndRestore()) {
                saveState();
            }
            
            updateStatsVisibility(false);
            console.log('Î•Ï†Î±ÏÎ¼Î¿Î³Î® Î£Ï‡ÎµÎ´Î¹Î±ÏƒÎ¼Î¿Ï Î”Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚ Î±ÏÏ‡Î¹ÎºÎ¿Ï€Î¿Î¹Î®Î¸Î·ÎºÎµ.');
        }

        function initUIElements() {
            bottomPanel = document.getElementById('bottomPanel');
            hidePanelButton = document.getElementById('hide-panel-button');
            showPanelButton = document.getElementById('show-panel-button');
        }
        
        function initMap() {
            state.map = L.map('map', {
                center: CONFIG.DEFAULT_CENTER,
                zoom: CONFIG.DEFAULT_ZOOM,
                zoomControl: true
            });
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(state.map);
            
            state.map.on('click', handleMapClick);
            state.map.on('contextmenu', handleMapRightClick);
            
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const { latitude, longitude } = position.coords;
                        state.map.setView([latitude, longitude], CONFIG.DEFAULT_ZOOM);
                    },
                    (error) => console.log('Î— Î³ÎµÏ‰ÎµÎ½Ï„Î¿Ï€Î¿Ï€Î¹ÏƒÎ· Î±Ï€Î­Ï„Ï…Ï‡Îµ:', error.message),
                    { timeout: 5000 }
                );
            }
        }
        
        function setupEventListeners() {
            document.getElementById('clearRoute').addEventListener('click', () => clearRoute(true));
            document.getElementById('downloadGPX').addEventListener('click', downloadGPX);
            document.getElementById('undoButton').addEventListener('click', undo);
            document.getElementById('shareButton').addEventListener('click', copyShareLink);

            // --- SEARCH FUNCTIONALITY ---
            const searchInput = document.getElementById('search-input');
            const suggestionsList = document.getElementById('search-suggestions');
            const debouncedSearch = debounce(fetchSearchSuggestions, 300);

            searchInput.addEventListener('input', () => {
                if (searchInput.value.trim().length >= 3) {
                    setSearchLoading(true);
                    debouncedSearch(searchInput.value);
                } else {
                    clearSuggestions();
                }
            });

            searchInput.addEventListener('keydown', handleSearchKeyDown);
            
            searchInput.addEventListener('blur', () => {
                setTimeout(() => {
                    if (!suggestionsList.contains(document.activeElement)) {
                        clearSuggestions();
                    }
                }, 150);
            });

            searchInput.addEventListener('search', () => {
                if (!searchInput.value) {
                    clearSuggestions();
                }
            });
            
            document.getElementById('search-icon-container').addEventListener('click', () => {
                if (searchInput.value) {
                    searchInput.value = '';
                    clearSuggestions();
                    searchInput.focus();
                }
            });

            // Menu toggle functionality
            const menuToggle = document.getElementById('menuToggle');
            const menuPanel = document.getElementById('menuPanel');
            const menuIcon = document.getElementById('menuIcon');
            const closeIcon = document.getElementById('closeIcon');
            
            menuToggle.addEventListener('click', () => {
                const isHidden = menuPanel.classList.contains('menu-hidden');
                if (isHidden) {
                    menuPanel.classList.remove('menu-hidden');
                    menuIcon.classList.add('hidden');
                    closeIcon.classList.remove('hidden');
                } else {
                    menuPanel.classList.add('menu-hidden');
                    menuIcon.classList.remove('hidden');
                    closeIcon.classList.add('hidden');
                }
            });

            // Panel visibility buttons
            hidePanelButton.addEventListener('click', hideBottomPanel);
            showPanelButton.addEventListener('click', showBottomPanel);

            // Toggles listeners
            document.getElementById('roundTripToggle').addEventListener('change', handleRoundTripToggle);
            document.getElementById('steepUphillToggle').addEventListener('change', handleSteepUphillToggle);

            // Drag route listeners
            state.map.on('mousemove', handleDragMove);
            state.map.on('mouseup', handleDragEnd);

            window.addEventListener('resize', () => {
                if (state.map) {
                    setTimeout(() => state.map.invalidateSize(), 100);
                }
            });

            setupTooltips();
        }

        // --- GENERIC TOOLTIP CREATION ---
        function setupTooltips() {
            createTooltipFor(
                document.getElementById('estimatedDuration'),
                `<strong>Î¤ÏÏŒÏ€Î¿Ï‚ Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼Î¿Ï:</strong><br>
                 â€¢ ÎœÎ­ÏƒÎ· Ï„Î±Ï‡ÏÏ„Î·Ï„Î± ÏƒÎµ ÎµÏ€Î¯Ï€ÎµÎ´Î¿: ${CONFIG.avgFlatSpeed || 15} km/h<br>
                 â€¢ Î ÏÏŒÏƒÎ¸ÎµÏ„Î¿Ï‚ Ï‡ÏÏŒÎ½Î¿Ï‚ Î³Î¹Î± Î±Î½Î¬Î²Î±ÏƒÎ·: 1 Î»ÎµÏ€Ï„ÏŒ Î±Î½Î¬ 10 Î¼Î­Ï„ÏÎ± Ï…ÏˆÎ¿Î¼ÎµÏ„ÏÎ¹ÎºÎ®Ï‚ Î´Î¹Î±Ï†Î¿ÏÎ¬Ï‚`
            );

            createTooltipFor(
                document.querySelector('#roundTripToggle').closest('label'),
                'Î‘Î½Î¿Î¯Î³Î¿Î½Ï„Î¬Ï‚ Ï„Î¿, Î· Î´Î¹Î±Î´ÏÎ¿Î¼Î® ÏƒÎ±Ï‚ Î³Ï…ÏÎ¯Î¶ÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Ï€Î¯ÏƒÏ‰ ÏƒÏ„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ ÎµÎºÎºÎ¯Î½Î·ÏƒÎ·Ï‚.'
            );

            createTooltipFor(
                document.querySelector('#steepUphillToggle').closest('label'),
                'Î”ÎµÎ¯Ï‡Î½ÎµÎ¹ Î¼Îµ ÎºÏŒÎºÎºÎ¹Î½Î¿ Ï‡ÏÏÎ¼Î± Ï„Î¹Ï‚ Î±Ï€ÏŒÏ„Î¿Î¼ÎµÏ‚ Î±Î½Î·Ï†ÏŒÏÎµÏ‚ (>5Â°) ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î·.'
            );
        }

        function createTooltipFor(element, htmlContent) {
            let tooltip = null;

            const showTooltip = () => {
                if (tooltip) return;

                tooltip = document.createElement('div');
                tooltip.className = 'info-tooltip';
                tooltip.innerHTML = htmlContent;
                document.body.appendChild(tooltip);
                
                positionTooltip();
                
                setTimeout(() => {
                    if (tooltip) tooltip.style.opacity = '1';
                }, 10);
            };

            const hideTooltip = () => {
                if (tooltip) {
                    tooltip.style.opacity = '0';
                    setTimeout(() => {
                        if (tooltip && tooltip.parentNode) {
                            tooltip.parentNode.removeChild(tooltip);
                        }
                        tooltip = null;
                    }, 200);
                }
            };
            
            const positionTooltip = () => {
                if (!tooltip) return;
                const rect = element.getBoundingClientRect();
                tooltip.style.left = `${rect.left + window.scrollX + (rect.width / 2) - (tooltip.offsetWidth / 2)}px`;
                tooltip.style.top = `${rect.top + window.scrollY - tooltip.offsetHeight - 10}px`;
            };

            element.addEventListener('mouseenter', showTooltip);
            element.addEventListener('mouseleave', hideTooltip);
            window.addEventListener('resize', positionTooltip);
            window.addEventListener('scroll', positionTooltip, true);
        }
        
        // --- UNDO/HISTORY MANAGEMENT ---
        function saveState() {
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }

            const snapshot = {
                pins: state.pins.map(p => ({ lat: p.lat, lng: p.lng })),
                routeViaPoints: state.routeViaPoints.map(v => ({ latlng: { lat: v.latlng.lat, lng: v.latlng.lng }, insertAfterIndex: v.insertAfterIndex })),
                isRoundTrip: state.isRoundTrip,
                showSteepHighlight: state.showSteepHighlight
            };
            state.history.push(snapshot);
            state.historyIndex++;

            if (state.history.length > CONFIG.HISTORY_LIMIT + 1) {
                state.history.shift();
                state.historyIndex--;
            }
            
            updateUndoButton();
        }

        function undo() {
            if (state.historyIndex <= 0) return;
            state.historyIndex--;
            const previousState = state.history[state.historyIndex];
            restoreState(previousState);
        }
        
        function restoreState(snapshot) {
            state.pins = snapshot.pins.map(p => L.latLng(p.lat, p.lng));
            state.routeViaPoints = snapshot.routeViaPoints.map(v => ({ latlng: L.latLng(v.latlng.lat, v.latlng.lng), insertAfterIndex: v.insertAfterIndex }));
            state.isRoundTrip = snapshot.isRoundTrip;
            state.showSteepHighlight = snapshot.showSteepHighlight ?? false;
            
            document.getElementById('roundTripToggle').checked = state.isRoundTrip;
            document.getElementById('steepUphillToggle').checked = state.showSteepHighlight;
            
            redrawFromState();
            updateUndoButton();
        }

        function redrawFromState() {
            state.markers.forEach(marker => state.map.removeLayer(marker));
            state.markers = [];
            state.routePolylines.forEach(p => state.map.removeLayer(p));
            state.routePolylines = [];
            state.routeArrows.forEach(a => state.map.removeLayer(a));
            state.routeArrows = [];
            if (state.polylineDecorator) {
                state.map.removeLayer(state.polylineDecorator);
                state.polylineDecorator = null;
            }
            
            state.pins.forEach((pin, index) => {
                addMarker(pin, index + 1);
            });
            
            calculateRoute();
            updateUIState();
        }
        
        // --- SHARE & URL FUNCTIONALITY ---
        function generateShareLink() {
            if (state.pins.length === 0) return null;

            const pinString = state.pins.map(p => `${p.lat.toFixed(5)},${p.lng.toFixed(5)}`).join('|');
            const viaString = state.routeViaPoints.map(v => `${v.latlng.lat.toFixed(5)},${v.latlng.lng.toFixed(5)},${v.insertAfterIndex}`).join('|');
            const dataString = `v1|${pinString}|${viaString}|${state.isRoundTrip}|${state.showSteepHighlight}`;
            const compressed = LZString.compressToEncodedURIComponent(dataString);

            const baseUrl = window.location.href.split('#')[0];
            return `${baseUrl}#${compressed}`;
        }

        function copyShareLink() {
            const link = generateShareLink();
            if (!link) {
                showMessage("Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®ÏƒÏ„Îµ Î¼Î¹Î± Î´Î¹Î±Î´ÏÎ¿Î¼Î® Ï€ÏÏÏ„Î±.", 'error');
                return;
            }

            navigator.clipboard.writeText(link).then(() => {
                showMessage('ÎŸ ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿Ï‚ Î±Î½Ï„Î¹Î³ÏÎ¬Ï†Î·ÎºÎµ ÏƒÏ„Î¿ Ï€ÏÏŒÏ‡ÎµÎ¹ÏÎ¿!', 'success');
            }).catch(err => {
                console.error('Failed to copy link: ', err);
                showMessage('Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î± Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î®Ï‚. ÎŸ ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿Ï‚ ÎµÎ¯Î½Î±Î¹: ' + link, 'error');
            });
        }

        function parseUrlAndRestore() {
            const hash = window.location.hash.substring(1);
            if (!hash) return false;

            try {
                const decompressed = LZString.decompressFromEncodedURIComponent(hash);
                if (!decompressed || !decompressed.startsWith('v1|')) {
                    console.warn('Invalid or old share link format.');
                    return false;
                }

                const parts = decompressed.split('|');
                parts.shift(); // remove "v1"

                const showSteepHighlight = parts.pop() === 'true';
                const isRoundTrip = parts.pop() === 'true';

                const viaString = parts.pop() || '';
                const viaParts = viaString ? viaString.split('|') : [];
                state.routeViaPoints = viaParts.map(v => {
                    const coords = v.split(',');
                    return { latlng: L.latLng(parseFloat(coords[0]), parseFloat(coords[1])), insertAfterIndex: parseInt(coords[2]) };
                });

                const pinString = parts.join('|');
                const pins = pinString.split('|').map(p => {
                    const coords = p.split(',');
                    return L.latLng(parseFloat(coords[0]), parseFloat(coords[1]));
                });

                if (pins.length > 0) {
                    const snapshot = { 
                        pins: pins.map(p => ({lat: p.lat, lng: p.lng})), 
                        routeViaPoints: state.routeViaPoints.map(v => ({ latlng: { lat: v.latlng.lat, lng: v.latlng.lng }, insertAfterIndex: v.insertAfterIndex })),
                        isRoundTrip,
                        showSteepHighlight
                    };
                    state.history = [snapshot];
                    state.historyIndex = 0;
                    restoreState(snapshot);
                    console.log('Route restored from URL.');
                    return true;
                }
            } catch (e) {
                console.error("Failed to parse URL hash:", e);
                showMessage("ÎŸ ÏƒÏÎ½Î´ÎµÏƒÎ¼Î¿Ï‚ Ï„Î·Ï‚ Î´Î¹Î±Î´ÏÎ¿Î¼Î®Ï‚ ÎµÎ¯Î½Î±Î¹ ÎºÎ±Ï„ÎµÏƒÏ„ÏÎ±Î¼Î¼Î­Î½Î¿Ï‚.", 'error');
            }
            return false;
        }

        // --- MAP INTERACTION ---
        function handleMapClick(e) {
            if (state.isDragging) return;
            if (state.pins.length >= CONFIG.MAX_PINS) {
                showMessage(`Î•Ï€Î¹Ï„ÏÎ­Ï€Î¿Î½Ï„Î±Î¹ Î¼Î­Ï‡ÏÎ¹ ${CONFIG.MAX_PINS} ÏƒÎ·Î¼ÎµÎ¯Î±.`, 'error');
                return;
            }
            
            const latlng = e.latlng;
            state.pins.push(latlng);
            addMarker(latlng, state.pins.length);
            
            calculateRoute();
            saveState();
            updateUIState();
        }
        
        function handleMapRightClick(e) {
            if (state.isDragging) return;
            e.originalEvent.preventDefault();
            if (state.pins.length === 0) return;

            let nearestIndex = -1;
            let minDistance = Infinity;
            
            state.pins.forEach((pin, index) => {
                const distance = e.latlng.distanceTo(pin);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestIndex = index;
                }
            });
            
            if (nearestIndex !== -1) {
                removePin(nearestIndex);
            }
        }

        function addMarker(latlng, number) {
            const marker = L.marker(latlng, {
                icon: createNumberedIcon(number, number === 1),
                draggable: true
            }).addTo(state.map);
            
            marker.on('dragend', (e) => {
                const index = state.markers.indexOf(marker);
                state.pins[index] = e.target.getLatLng();
                calculateRoute();
                saveState();
            });
            
            state.markers.push(marker);
        }

        function removePin(index) {
            if (index < 0 || index >= state.pins.length) return;
            
            state.map.removeLayer(state.markers[index]);
            state.pins.splice(index, 1);
            state.markers.splice(index, 1);
            
            state.markers.forEach((marker, i) => {
                marker.setIcon(createNumberedIcon(i + 1, i === 0));
            });
            
            // Remove any via points that reference this pin
            state.routeViaPoints = state.routeViaPoints.filter(v => v.insertAfterIndex !== index);
            state.routeViaPoints.forEach(v => {
                if (v.insertAfterIndex > index) v.insertAfterIndex--;
            });

            calculateRoute();
            saveState();
            updateUIState();
        }

        function createNumberedIcon(number, isStart = false) {
            const baseClass = 'pin-icon' + (isStart ? ' start' : '');
            return L.divIcon({
                className: baseClass,
                html: number.toString(),
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        function handleRoundTripToggle(e) {
            state.isRoundTrip = e.target.checked;
            calculateRoute();
            saveState();
        }

        function handleSteepUphillToggle(e) {
            state.showSteepHighlight = e.target.checked;
            if (state.currentRoute) {
                displayColoredRoute(state.currentRoute.coordinates);
            }
            saveState();
        }
        
        // --- LOCATION SEARCH LOGIC ---
        function getConciseLocationName(item) {
            const primaryName = item.name;
            if (!primaryName) return item.display_name;

            const secondaryName = item.address?.city || item.address?.town || item.address?.village;
            
            let displayText = primaryName;
            if (secondaryName && primaryName !== secondaryName) {
                 displayText += `, ${secondaryName}`;
            }
            return displayText;
        }

        async function fetchSearchSuggestions(query) {
            if (!query.trim()) {
                clearSuggestions();
                setSearchLoading(false);
                return;
            }

            try {
                const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&addressdetails=1&limit=5&countrycodes=gr&accept-language=el`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Î— Ï…Ï€Î·ÏÎµÏƒÎ¯Î± Î±Î½Î±Î¶Î®Ï„Î·ÏƒÎ·Ï‚ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î·.');
                const data = await response.json();
                
                state.searchSuggestions = data;
                renderSuggestions(data);
            } catch (error) {
                console.error('Search error:', error);
                clearSuggestions();
            } finally {
                setSearchLoading(false);
            }
        }

        function renderSuggestions(suggestions) {
            const suggestionsList = document.getElementById('search-suggestions');
            suggestionsList.innerHTML = '';
            suggestionsList.classList.remove('hidden');

            if (suggestions.length === 0) {
                suggestionsList.innerHTML = `<li class="text-gray-500 italic">Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ Î±Ï€Î¿Ï„ÎµÎ»Î­ÏƒÎ¼Î±Ï„Î±</li>`;
                return;
            }

            suggestions.forEach((item, index) => {
                const li = document.createElement('li');
                li.textContent = getConciseLocationName(item);
                li.dataset.index = index;
                li.addEventListener('click', () => selectSuggestion(item));
                
                li.addEventListener('mouseenter', (e) => {
                    if (activeSearchTooltip) activeSearchTooltip.remove();

                    const currentItem = state.searchSuggestions[parseInt(e.currentTarget.dataset.index)];
                    if (!currentItem) return;

                    activeSearchTooltip = document.createElement('div');
                    activeSearchTooltip.className = 'search-result-tooltip';
                    activeSearchTooltip.innerHTML = currentItem.display_name;
                    document.body.appendChild(activeSearchTooltip);

                    const rect = e.currentTarget.getBoundingClientRect();
                    activeSearchTooltip.style.top = `${rect.top}px`;
                    activeSearchTooltip.style.left = `${rect.right + 10}px`;

                    const tooltipRect = activeSearchTooltip.getBoundingClientRect();
                    if (tooltipRect.right > window.innerWidth) {
                        activeSearchTooltip.style.left = `${rect.left - tooltipRect.width - 10}px`;
                    }
                    
                    setTimeout(() => {
                        if (activeSearchTooltip) activeSearchTooltip.style.opacity = '1';
                    }, 50);
                });

                li.addEventListener('mouseleave', () => {
                    if (activeSearchTooltip) {
                        activeSearchTooltip.style.opacity = '0';
                        setTimeout(() => {
                            if (activeSearchTooltip) activeSearchTooltip.remove();
                            activeSearchTooltip = null;
                        }, 200);
                    }
                });

                suggestionsList.appendChild(li);
            });
            state.highlightedSuggestionIndex = -1;
        }

        function selectSuggestion(item) {
            const lat = parseFloat(item.lat);
            const lon = parseFloat(item.lon);
            
            if (state.searchResultMarker) state.map.removeLayer(state.searchResultMarker);
            
            state.map.flyTo([lat, lon], 15);

            state.searchResultMarker = L.marker([lat, lon])
              .addTo(state.map)
              .bindPopup(`<b>${item.display_name}</b>`)
              .openPopup();

            document.getElementById('search-input').value = getConciseLocationName(item);
            clearSuggestions();
        }

        function handleSearchKeyDown(e) {
            const suggestionsList = document.getElementById('search-suggestions');
            const items = suggestionsList.querySelectorAll('li');
            if (items.length === 0) return;

            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    state.highlightedSuggestionIndex = (state.highlightedSuggestionIndex + 1) % items.length;
                    updateSuggestionHighlight();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    state.highlightedSuggestionIndex = (state.highlightedSuggestionIndex - 1 + items.length) % items.length;
                    updateSuggestionHighlight();
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (state.highlightedSuggestionIndex > -1) {
                        selectSuggestion(state.searchSuggestions[state.highlightedSuggestionIndex]);
                    }
                    break;
                case 'Escape':
                    clearSuggestions();
                    break;
            }
        }

        function updateSuggestionHighlight() {
            const items = document.getElementById('search-suggestions').querySelectorAll('li');
            items.forEach((item, index) => {
                if (index === state.highlightedSuggestionIndex) {
                    item.classList.add('highlighted');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('highlighted');
                }
            });
        }
        
        let activeSearchTooltip = null;
        function clearSuggestions() {
            const suggestionsList = document.getElementById('search-suggestions');
            suggestionsList.innerHTML = '';
            suggestionsList.classList.add('hidden');
            state.searchSuggestions = [];
            state.highlightedSuggestionIndex = -1;
            
            if (activeSearchTooltip) {
                activeSearchTooltip.remove();
                activeSearchTooltip = null;
            }
        }

        function setSearchLoading(isLoading) {
            state.isSearchLoading = isLoading;
            document.getElementById('search-spinner').classList.toggle('hidden', !isLoading);
            document.getElementById('search-magnifying-glass').classList.toggle('hidden', isLoading);
        }

        // --- ROUTE & ELEVATION CALCULATION ---
        async function calculateRoute() {
            if (state.pins.length < 2) {
                clearRoute(false);
                return;
            }
            
            showLoading(true);

            try {
                let routeData = null;
                const apis = [() => fetchFromORS(), () => fetchFromGraphHopper()];

                for (const fetchFunc of apis) {
                    try {
                        routeData = await fetchFunc();
                        if (routeData) break;
                    } catch (error) {
                        console.warn(`${fetchFunc.name} failed:`, error.message);
                    }
                }

                if (!routeData) throw new Error('ÎŒÎ»ÎµÏ‚ Î¿Î¹ Ï…Ï€Î·ÏÎµÏƒÎ¯ÎµÏ‚ Î´ÏÎ¿Î¼Î¿Î»ÏŒÎ³Î·ÏƒÎ·Ï‚ Î±Ï€Î­Ï„Ï…Ï‡Î±Î½.');

                if (routeData.coordinates.length > 0 && routeData.coordinates[0].length === 2) {
                    console.log("Fetching elevation separately...");
                    const elevations = await fetchElevationSeparately(routeData.coordinates);
                    routeData.coordinates.forEach((coord, index) => {
                        coord.push(elevations[index] || 0);
                    });
                }
                
                state.currentRoute = routeData;
                processElevationData(routeData.coordinates);

            } catch (error) {
                showMessage(error.message, 'error');
                console.error('Route calculation error:', error);
            } finally {
                showLoading(false);
            }
        }

        async function fetchFromORS() {
            console.log("Attempting to fetch route from OpenRouteService...");
            let pinsForRoute = [...state.pins];
            if (state.isRoundTrip && pinsForRoute.length >= 2) {
                pinsForRoute.push(pinsForRoute[0]);
            }

            // Build coordinates with via points
            let coordinates = pinsForRoute.map(pin => [pin.lng, pin.lat]);
            
            // Insert via points
            state.routeViaPoints.forEach(via => {
                if (via.insertAfterIndex < coordinates.length - 1) {
                    coordinates.splice(via.insertAfterIndex + 1, 0, [via.latlng.lng, via.latlng.lat]);
                }
            });

            const response = await fetch('https://api.openrouteservice.org/v2/directions/cycling-regular/geojson', {
                method: 'POST',
                headers: {
                    'Authorization': CONFIG.OPENROUTE_API_KEY,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    coordinates: coordinates,
                    instructions: false,
                    elevation: true
                })
            });

            if (!response.ok) throw new Error(`ORS API error: ${response.status}`);
            const data = await response.json();
            if (!data.features?.[0]) throw new Error('Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î±Ï€ÏŒ Ï„Î¿ ORS');
            
            const route = data.features[0];
            console.log("Success from OpenRouteService.");
            return {
                coordinates: route.geometry.coordinates.map(c => [c[1], c[0], c[2]]), // lat, lng, elevation
                distance: route.properties.summary?.distance || 0,
            };
        }

        async function fetchFromGraphHopper() {
            console.log("Attempting to fetch route from GraphHopper...");
            let pinsForRoute = [...state.pins];
            if (state.isRoundTrip && pinsForRoute.length >= 2) {
                pinsForRoute.push(pinsForRoute[0]);
            }

            // Build points with via points
            let points = pinsForRoute.map(pin => `point=${pin.lat},${pin.lng}`);
            
            // Insert via points
            state.routeViaPoints.forEach(via => {
                if (via.insertAfterIndex < pinsForRoute.length - 1) {
                    points.splice(via.insertAfterIndex + 1, 0, `point=${via.latlng.lat},${via.latlng.lng}`);
                }
            });

            const url = `https://graphhopper.com/api/1/route?${points.join('&')}&vehicle=bike&calc_points=true&points_encoded=false&type=json&key=${CONFIG.GRAPHHOPPER_KEY}`;
            
            const response = await fetch(url);
            if (!response.ok) throw new Error(`GraphHopper API error: ${response.status}`);
            const data = await response.json();
            if (!data.paths?.[0]) throw new Error('Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î±Ï€ÏŒ Ï„Î¿ GraphHopper');

            const path = data.paths[0];
            console.log("Success from GraphHopper.");
            return {
                coordinates: path.points.coordinates.map(c => [c[1], c[0]]), // lat, lng (no elevation)
                distance: path.distance,
            };
        }

        async function fetchElevationSeparately(coordinates) {
            const maxPoints = 300;
            let pointsToFetch = coordinates;
            if (coordinates.length > maxPoints) {
                pointsToFetch = [];
                const step = Math.floor(coordinates.length / maxPoints);
                for (let i = 0; i < coordinates.length; i += step) {
                    pointsToFetch.push(coordinates[i]);
                }
            }

            const response = await fetch(CONFIG.ELEVATION_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    locations: pointsToFetch.map(c => ({ latitude: c[0], longitude: c[1] }))
                })
            });
            if (!response.ok) throw new Error('Elevation API failed');
            const data = await response.json();
            const elevations = data.results.map(r => r.elevation);

            if (coordinates.length > maxPoints) {
                const fullElevations = [];
                for(let i = 0; i < coordinates.length; i++) {
                    const step = Math.floor(coordinates.length / maxPoints);
                    const prevIndex = Math.floor(i / step);
                    const nextIndex = Math.min(prevIndex + 1, elevations.length - 1);
                    
                    if (prevIndex === nextIndex) {
                        fullElevations.push(elevations[prevIndex]);
                        continue;
                    }

                    const prevElev = elevations[prevIndex];
                    const nextElev = elevations[nextIndex];
                    const ratio = (i % step) / step;
                    fullElevations.push(prevElev + (nextElev - prevElev) * ratio);
                }
                return fullElevations;
            }
            return elevations;
        }
        
        function processElevationData(routeCoordinates) {
            let cumulativeDistance = 0;
            let elevationGain = 0;
            let elevationLoss = 0;
            let steepUphillDistance = 0;
            const elevationProfileData = [];
            
            routeCoordinates.forEach((point, index) => {
                const elevation = point[2];
                if (index > 0) {
                    const prevPoint = routeCoordinates[index - 1];
                    const segmentDistance = calculateHaversineDistance(prevPoint, point);
                    cumulativeDistance += segmentDistance;

                    const elevationDiff = elevation - (prevPoint[2] || 0);
                    if (elevationDiff > 0) elevationGain += elevationDiff;
                    else elevationLoss += Math.abs(elevationDiff);

                    if (segmentDistance > 0) {  
                        const gradient = Math.atan(elevationDiff / segmentDistance) * (180 / Math.PI);
                        if (gradient > CONFIG.STEEP_GRADIENT_THRESHOLD) {
                             steepUphillDistance += segmentDistance;
                        }
                    }
                }
                elevationProfileData.push({ distance: cumulativeDistance, elevation: elevation });
            });

            const maxChartPoints = 300;
            let sampledElevationData = elevationProfileData;
            let sampledRouteCoords = routeCoordinates;

            if (elevationProfileData.length > maxChartPoints) {
                sampledElevationData = [];
                sampledRouteCoords = [];
                const step = Math.floor(elevationProfileData.length / maxChartPoints);
                for (let i = 0; i < elevationProfileData.length; i += step) {
                    sampledElevationData.push(elevationProfileData[i]);
                    sampledRouteCoords.push(routeCoordinates[i]);
                }
            }

            state.currentElevation = { data: sampledElevationData, coordinates: sampledRouteCoords };

            updateRouteStats({ distance: cumulativeDistance, elevationGain, elevationLoss, steepUphillDistance });
            displayColoredRoute(routeCoordinates);
            updateStatsVisibility(true);
            showBottomPanel();
        }
        
        // --- UI UPDATES & DISPLAY ---
        function showBottomPanel() {
            if (!state.currentRoute && state.pins.length < 2) return;
            bottomPanel.classList.add('is-visible');
            showPanelButton.classList.add('hidden');
        }

        function hideBottomPanel() {
            bottomPanel.classList.remove('is-visible');
            if (state.currentRoute || state.pins.length >= 2) {
                showPanelButton.classList.remove('hidden');
            }
        }

        function displayColoredRoute(routeCoordinates) {
            state.routePolylines.forEach(p => state.map.removeLayer(p));
            state.routeArrows.forEach(a => state.map.removeLayer(a));
            state.routePolylines = [];
            state.routeArrows = [];

            if (state.polylineDecorator) {
                state.map.removeLayer(state.polylineDecorator);
                state.polylineDecorator = null;
            }
            
            if (state.draggingPolyline) {
                state.map.removeLayer(state.draggingPolyline);
                state.draggingPolyline = null;
            }

            // Create invisible wide draggable line for better UX
            const invisibleLine = L.polyline(routeCoordinates.map(c => [c[0], c[1]]), {
                color: 'transparent',
                weight: 20, // Much wider for easier clicking
                opacity: 0,
                className: 'route-draggable'
            }).addTo(state.map);
            invisibleLine.on('mousedown', handleRouteMouseDown);
            state.routePolylines.push(invisibleLine);

            if (state.showSteepHighlight) {
                let currentSegment = [];
                let isCurrentSegmentSteep = false;
                let allSegments = [];

                for (let i = 1; i < routeCoordinates.length; i++) {
                    const startPoint = routeCoordinates[i - 1];
                    const endPoint = routeCoordinates[i];
                    const segmentDistance = calculateHaversineDistance(startPoint, endPoint);
                    const elevationDiff = endPoint[2] - startPoint[2];
                    let isSteep = false;

                    if (segmentDistance > 0) {
                        const gradient = Math.atan(elevationDiff / segmentDistance) * (180 / Math.PI);
                        if (gradient > CONFIG.STEEP_GRADIENT_THRESHOLD) isSteep = true;
                    }

                    if (i === 1) {
                        currentSegment.push([startPoint[0], startPoint[1]]);
                        isCurrentSegmentSteep = isSteep;
                    }

                    if (isSteep !== isCurrentSegmentSteep) {
                        currentSegment.push([endPoint[0], endPoint[1]]);
                        allSegments.push({ coords: [...currentSegment], isSteep: isCurrentSegmentSteep });
                        currentSegment = [[endPoint[0], endPoint[1]]];
                        isCurrentSegmentSteep = isSteep;
                    } else {
                        currentSegment.push([endPoint[0], endPoint[1]]);
                    }
                }

                if (currentSegment.length > 1) {
                    allSegments.push({ coords: [...currentSegment], isSteep: isCurrentSegmentSteep });
                }

                allSegments.forEach(segment => {
                    const polyline = L.polyline(segment.coords, {
                        color: segment.isSteep ? '#EF4444' : '#3B82F6', 
                        weight: 5, 
                        opacity: 0.85,
                        className: 'route-line'
                    }).addTo(state.map);
                    state.routePolylines.push(polyline);
                });
            } else {
                const fullRouteCoords = routeCoordinates.map(c => [c[0], c[1]]);
                const polyline = L.polyline(fullRouteCoords, {
                    color: '#3B82F6', 
                    weight: 5, 
                    opacity: 0.85,
                    className: 'route-line'
                }).addTo(state.map);
                state.routePolylines.push(polyline);
            }

            const fullPolyline = L.polyline(routeCoordinates.map(c => [c[0], c[1]]), { color: 'transparent' }).addTo(state.map);
            state.routePolylines.push(fullPolyline);

            state.polylineDecorator = L.polylineDecorator(fullPolyline, {
                patterns: [{
                    offset: '10%', repeat: '400px',
                    symbol: L.Symbol.arrowHead({ pixelSize: 6, polygon: false, pathOptions: { stroke: true, weight: 1.5, color: '#000000', opacity: 0.9 } })
                }]
            }).addTo(state.map);
            state.routeArrows.push(state.polylineDecorator);

            const group = new L.featureGroup([...state.routePolylines, ...state.markers]);
            state.map.fitBounds(group.getBounds(), { padding: [60, 60] });
        }

        // --- DRAG ROUTE FUNCTIONALITY - IMPROVED ---
        function handleRouteMouseDown(e) {
            if (state.pins.length < 2) return;
            if (state.routeViaPoints.length >= CONFIG.MAX_VIA_POINTS) {
                showMessage(`ÎœÎ­Î³Î¹ÏƒÏ„Î¿ ${CONFIG.MAX_VIA_POINTS} ÏƒÎ·Î¼ÎµÎ¯Î± ÎµÏ€Î±Î½Î±Î´ÏÎ¿Î¼Î¿Î»ÏŒÎ³Î·ÏƒÎ·Ï‚.`, 'error');
                return;
            }

            state.isDragging = true;
            state.map.dragging.disable();
            state.dragStartLatLng = e.latlng;

            // Create ghost waypoint
            if (state.ghostWaypoint) state.map.removeLayer(state.ghostWaypoint);
            state.ghostWaypoint = L.circleMarker(e.latlng, {
                radius: 8,
                fillColor: "#F59E0B",
                color: "#fff",
                weight: 3,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(state.map);

            // Create ghost line
            if (state.ghostLine) state.map.removeLayer(state.ghostLine);

            // Find the segment index
            const routeCoords = state.currentRoute ? state.currentRoute.coordinates : [];
            if (routeCoords.length === 0) return;

            let closestSegmentIndex = 0;
            let minDistance = Infinity;

            for (let i = 0; i < routeCoords.length - 1; i++) {
                const dist = pointToSegmentDistance(
                    e.latlng,
                    L.latLng(routeCoords[i][0], routeCoords[i][1]),
                    L.latLng(routeCoords[i + 1][0], routeCoords[i + 1][1])
                );
                if (dist < minDistance) {
                    minDistance = dist;
                    closestSegmentIndex = i;
                }
            }

            // Determine which pin this segment belongs to
            const segmentsPerPin = (routeCoords.length - 1) / (state.pins.length - 1);
            state.dragSegmentIndex = Math.floor(closestSegmentIndex / segmentsPerPin);

            e.originalEvent.preventDefault();
        }

        function handleDragMove(e) {
            if (!state.isDragging || !state.ghostWaypoint) return;

            const latlng = e.latlng;
            state.ghostWaypoint.setLatLng(latlng);

            // Update ghost line to show preview
            if (!state.ghostLine) {
                state.ghostLine = L.polyline([], {
                    color: '#3B82F6',
                    weight: 5,
                    opacity: 0.7,
                    dashArray: '5, 10'
                }).addTo(state.map);
            }

            // Find the relevant pins
            const segmentIndex = state.dragSegmentIndex;
            const startPin = state.pins[segmentIndex];
            const endPin = segmentIndex + 1 < state.pins.length 
                ? state.pins[segmentIndex + 1] 
                : (state.isRoundTrip ? state.pins[0] : null);

            if (startPin && endPin) {
                state.ghostLine.setLatLngs([
                    [startPin.lat, startPin.lng],
                    [latlng.lat, latlng.lng],
                    [endPin.lat, endPin.lng]
                ]);
            }
        }

        function handleDragEnd(e) {
            if (!state.isDragging) return;

            state.isDragging = false;
            state.map.dragging.enable();

            const latlng = e.latlng;

            // Clean up ghost elements
            if (state.ghostWaypoint) {
                state.map.removeLayer(state.ghostWaypoint);
                state.ghostWaypoint = null;
            }
            if (state.ghostLine) {
                state.map.removeLayer(state.ghostLine);
                state.ghostLine = null;
            }

            // Add via point and recalculate route
            if (state.routeViaPoints.length < CONFIG.MAX_VIA_POINTS) {
                state.routeViaPoints.push({ 
                    latlng: latlng, 
                    insertAfterIndex: state.dragSegmentIndex 
                });
                
                // Remove duplicates and sort
                state.routeViaPoints = state.routeViaPoints.filter((via, index, self) => 
                    index === self.findIndex(v => 
                        v.insertAfterIndex === via.insertAfterIndex && 
                        v.latlng.lat === via.latlng.lat && 
                        v.latlng.lng === via.latlng.lng
                    )
                );
                
                calculateRoute();
                saveState();
            }

            state.dragStartLatLng = null;
        }

        function pointToSegmentDistance(p, a, b) {
            const ab = b.subtract(a);
            const ap = p.subtract(a);
            const t = Math.max(0, Math.min(1, L.LineUtil.dot(ap, ab) / L.LineUtil.dot(ab, ab)));
            const projection = a.add(ab.multiplyBy(t));
            return p.distanceTo(projection);
        }

        function updateRouteStats(data) {
            const formatDistance = (d) => d > 1000 ? `${(d / 1000).toFixed(2)} km` : `${Math.round(d)} m`;
            
            document.getElementById('totalDistance').textContent = formatDistance(data.distance);
            document.getElementById('steepUphillDistance').textContent = formatDistance(data.steepUphillDistance);
            document.getElementById('elevationGain').textContent = `+${Math.round(data.elevationGain)} m`;
            document.getElementById('elevationLoss').textContent = `-${Math.round(data.elevationLoss)} m`;
            
            calculateAndDisplayDuration(data.distance, data.elevationGain);
        }
        
        async function displayElevationChart(elevationData) {
            try {
                await loadChartJs();
            } catch {
                showMessage('Î‘Ï€Î¿Ï„Ï…Ï‡Î¯Î± Ï†ÏŒÏÏ„Ï‰ÏƒÎ·Ï‚ Ï„Î¿Ï… Î³ÏÎ±Ï†Î®Î¼Î±Ï„Î¿Ï‚.', 'error');
                return;
            }

            const ctx = document.getElementById('elevationChart').getContext('2d');
            if (state.elevationChart) state.elevationChart.destroy();
            document.getElementById('no-elevation-message').style.display = 'none';

            const labels = elevationData.map(d => (d.distance / 1000).toFixed(2));
            const smoothed = smoothElevation(elevationData);
            const elevations = smoothed.map(d => d.elevation);
            
            state.elevationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Î¥ÏˆÏŒÎ¼ÎµÏ„ÏÎ¿ (m)', data: elevations, borderColor: '#3B82F6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)', borderWidth: 2,
                        fill: true, pointRadius: 0, pointHoverRadius: 5, tension: 0.6
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    scales: {
                        x: { title: { display: true, text: 'Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ· (km)' }, ticks: { autoSkip: true, maxTicksLimit: 10 } },
                        y: { title: { display: true, text: 'Î¥ÏˆÏŒÎ¼ÎµÏ„ÏÎ¿ (m)' } }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (ctx) => `Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·: ${ctx[0].label} km`,
                                label: (ctx) => `Î¥ÏˆÏŒÎ¼ÎµÏ„ÏÎ¿: ${Math.round(ctx.raw)} m`
                            }
                        }
                    },
                    onHover: (event, chartElement) => {
                        if (chartElement.length > 0) {
                            const index = chartElement[0].index;
                            const coord = state.currentElevation.coordinates[index];
                            if (coord) {
                                const latlng = [coord[0], coord[1]];
                                if (!state.highlightMarker) {
                                    state.highlightMarker = L.circleMarker(latlng, {
                                        radius: 8, fillColor: "#F59E0B", color: "#fff", weight: 2, opacity: 1, fillOpacity: 0.9
                                    }).addTo(state.map);
                                } else {
                                    state.highlightMarker.setLatLng(latlng);
                                }
                            }
                        } else if (state.highlightMarker) {
                            state.map.removeLayer(state.highlightMarker);
                            state.highlightMarker = null;
                        }
                    }
                }
            });

            function smoothElevation(data, windowSize = 5) {
                return data.map((_, i, arr) => {
                    const start = Math.max(0, i - Math.floor(windowSize / 2));
                    const end = Math.min(arr.length, i + Math.floor(windowSize / 2) + 1);
                    const slice = arr.slice(start, end);
                    const avgElevation = slice.reduce((sum, d) => sum + d.elevation, 0) / slice.length;
                    return { ...arr[i], elevation: avgElevation };
                });
            }

            document.getElementById('elevationChart').addEventListener('mouseleave', () => {
                if (state.highlightMarker) {
                    state.map.removeLayer(state.highlightMarker);
                    state.highlightMarker = null;
                }
            });
        }
        
        // --- UTILITY & HELPER FUNCTIONS ---
        function clearRoute(clearPins) {
            if (clearPins) {
                state.markers.forEach(marker => state.map.removeLayer(marker));
                state.markers = [];
                state.pins = [];
                state.routeViaPoints = [];
                document.getElementById('roundTripToggle').checked = false;
                state.isRoundTrip = false;
                document.getElementById('steepUphillToggle').checked = false;
                state.showSteepHighlight = false;
                
                state.history = [];
                state.historyIndex = -1;
                saveState();
            }
            
            state.routePolylines.forEach(p => state.map.removeLayer(p));
            state.routeArrows.forEach(a => state.map.removeLayer(a));
            state.routePolylines = [];
            state.routeArrows = [];

            if (state.polylineDecorator) {
                state.map.removeLayer(state.polylineDecorator);
                state.polylineDecorator = null;
            }
            
            if (state.ghostWaypoint) {
                state.map.removeLayer(state.ghostWaypoint);
                state.ghostWaypoint = null;
            }
            if (state.ghostLine) {
                state.map.removeLayer(state.ghostLine);
                state.ghostLine = null;
            }
            
            if (state.elevationChart) {
                state.elevationChart.destroy();
                state.elevationChart = null;
            }
            if (state.highlightMarker) {
                state.map.remove
                                state.map.removeLayer(state.highlightMarker);
                state.highlightMarker = null;
            }
            if (state.searchResultMarker) {
                state.map.removeLayer(state.searchResultMarker);
                state.searchResultMarker = null;
            }
            
            state.currentRoute = null;
            state.currentElevation = { data: [], coordinates: [] };
            
            hideBottomPanel();
            updateStatsVisibility(false);
            document.getElementById('no-elevation-message').style.display = 'flex';
            document.getElementById('estimatedDuration').textContent = '--';
            updateUIState();
        }

        function downloadGPX() {
            if (!state.currentRoute) {
                showMessage('Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î´Î¹Î±Î´ÏÎ¿Î¼Î® Î³Î¹Î± Î»Î®ÏˆÎ·', 'error');
                return;
            }
            
            const gpxContent = generateGPX(state.currentRoute);
            const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `route_${new Date().toISOString().slice(0,10)}.gpx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function generateGPX(route) {
            const timestamp = new Date().toISOString();
            let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Route Planner" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata><time>${timestamp}</time></metadata>
  <trk><name>Planned Route</name><trkseg>`;
            
            route.coordinates.forEach(coord => {
                gpx += `\n      <trkpt lat="${coord[0]}" lon="${coord[1]}"><ele>${coord[2] || 0}</ele></trkpt>`;
            });
            
            gpx += `\n    </trkseg></trk></gpx>`;
            return gpx;
        }

        function calculateHaversineDistance(coords1, coords2) {
            const R = 6371e3; // metres
            const Ï†1 = coords1[0] * Math.PI/180;
            const Ï†2 = coords2[0] * Math.PI/180;
            const Î”Ï† = (coords2[0]-coords1[0]) * Math.PI/180;
            const Î”Î» = (coords2[1]-coords1[1]) * Math.PI/180;

            const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) + Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
       function calculateAndDisplayDuration(distance, elevationGain) {
            if (distance === 0) {
                document.getElementById('estimatedDuration').textContent = '--';
                return;
            }

            const avgFlatSpeed = CONFIG.avgFlatSpeed || 15; // km/h
            const elevationPenaltyMinutes = (elevationGain / 10) * 1;

            const flatTimeMinutes = (distance / 1000) / avgFlatSpeed * 60;
            const totalMinutes = Math.round(flatTimeMinutes + elevationPenaltyMinutes);

            if (totalMinutes < 60) {
                document.getElementById('estimatedDuration').textContent = `${totalMinutes} min`;
            } else {
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                document.getElementById('estimatedDuration').textContent = `${hours}h ${minutes}m`;
            }
        }
        
        function debounce(func, delay) {
            let timeout;
            const debounced = function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
            debounced.cancel = () => clearTimeout(timeout);
            return debounced;
        }

        function loadChartJs() {
            return new Promise((resolve, reject) => {
                if (state.isChartJsLoaded) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js';
                script.onload = () => {
                    state.isChartJsLoaded = true;
                    console.log('Chart.js loaded dynamically.');
                    resolve();
                };
                script.onerror = () => {
                    console.error('Failed to load Chart.js');
                    reject(new Error('Failed to load Chart.js'));
                };
                document.head.appendChild(script);
            });
        }

        function showLoading(show) {
            document.getElementById('topRightLoader').classList.toggle('hidden', !show);
        }
        
        function showMessage(message, type = 'error') {
            const el = document.getElementById('messageOverlay');
            document.getElementById('messageText').textContent = message;
            
            el.className = 'absolute top-24 left-1/2 transform -translate-x-1/2 px-4 py-3 rounded-md shadow-lg z-[4000]';
            if (type === 'error') {
                el.classList.add('bg-red-100', 'border', 'border-red-400', 'text-red-700');
            } else { // success
                el.classList.add('bg-green-100', 'border', 'border-green-400', 'text-green-700');
            }

            el.style.display = 'block';
            el.classList.remove('message-fade');
            setTimeout(() => el.classList.add('message-fade'), 4500);
        }
        
        function updateUIState() {
            const hasPins = state.pins.length > 0;
            const hasRoute = state.pins.length >= 2;
            
            document.getElementById('instructions').style.display = hasPins ? 'none' : 'block';
            document.getElementById('downloadGPX').style.display = hasRoute ? 'flex' : 'none';
            document.getElementById('shareButton').disabled = !hasPins;
            showPanelButton.classList.toggle('hidden', !hasRoute || bottomPanel.classList.contains('is-visible'));
            updateUndoButton();
        }
        
        function updateUndoButton() {
            document.getElementById('undoButton').disabled = state.historyIndex <= 0;
        }

        function updateStatsVisibility(show) {
            document.getElementById('stats-content').style.display = show ? 'block' : 'none';
            document.getElementById('no-stats-message').style.display = show ? 'none' : 'flex';
        }
    </script>
</body>
</html>