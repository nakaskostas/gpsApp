<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Σχεδιαστής Διαδρομής</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>

    <style>
        /*  … (existing styles unchanged) …  */

        /* NEW: Search bar styling */
        .search-wrapper {
            position: relative;
            margin-bottom: 0.75rem;
        }
        .search-input {
            width: 100%;
            padding: 0.5rem 2.5rem 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }
        .search-input:focus {
            outline: 2px solid #3b82f6;
            border-color: transparent;
        }
        .search-btn {
            position: absolute;
            right: 0.25rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            color: #6b7280;
        }
        .search-btn:hover {
            color: #3b82f6;
        }
    </style>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 flex flex-col h-screen overflow-hidden">

    <!-- Map container -->
    <div class="flex-grow relative" style="height: 70vh;">
        <div id="map"></div>

        <!-- Menu toggle button -->
        <button id="menuToggle" class="menu-button" title="Μενού">
            <svg id="menuIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
            </svg>
            <svg id="closeIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
        </button>

        <!-- Floating Menu Panel -->
        <div id="menuPanel" class="menu-panel menu-hidden">
            <h1 class="text-xl font-bold mb-4 text-gray-800 flex items-center gap-2">
                <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                </svg>
                Σχεδιαστής Διαδρομής
            </h1>

            <!-- NEW: Search bar -->
            <div class="search-wrapper">
                <input id="searchInput" class="search-input" type="text" placeholder="Αναζήτηση περιοχής..." autocomplete="off">
                <button id="searchBtn" class="search-btn" title="Αναζήτηση">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                    </svg>
                </button>
            </div>

            <div class="flex flex-col gap-3">
                <button id="clearRoute" class="flex items-center justify-center gap-2 px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors shadow-sm">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                    </svg>
                    Καθαρισμός
                </button>
                <button id="downloadGPX" class="flex items-center justify-center gap-2 px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors shadow-sm" style="display: none;">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    Λήψη GPX
                </button>
            </div>
        </div>

        <!-- Error / Loading / Instructions overlays (unchanged) -->
        <div id="errorMessage" class="absolute top-24 left-1/2 transform -translate-x-1/2 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md shadow-lg z-40" style="display: none;">
            <span id="errorText"></span>
        </div>
        <div id="loadingMessage" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-blue-500 text-white px-6 py-4 rounded-lg shadow-xl z-50 flex items-center gap-4" style="display: none;">
            <div class="loading-spinner"></div>
            <span class="font-semibold">Υπολογισμός διαδρομής...</span>
        </div>
        <div id="instructions" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-blue-50 border border-blue-200 px-4 py-2 rounded-lg shadow-lg z-30">
            <p class="text-blue-800 text-sm font-medium">
                Κάντε κλικ στον χάρτη για να προσθέσετε σημεία. Δεξί κλικ για αφαίρεση.
            </p>
        </div>
    </div>

    <!-- Bottom stats & elevation (unchanged) -->
    <div class="flex bg-white border-t border-gray-200 shadow-inner" style="height: 30vh;">
        <div id="stats-panel" class="w-[30%] p-4 border-r border-gray-200 overflow-y-auto">
            <h2 class="text-lg font-bold mb-4 text-gray-800">Στατιστικά Διαδρομής</h2>
            <div id="stats-content" class="space-y-4">
                <div class="text-center p-3 bg-gray-50 rounded-lg">
                    <div class="text-gray-500 text-xs uppercase tracking-wider font-semibold">Συνολική Απόσταση</div>
                    <div id="totalDistance" class="font-bold text-2xl text-blue-600 mt-1">--</div>
                </div>
                <div class="text-center p-3 bg-gray-50 rounded-lg">
                    <div class="text-gray-500 text-xs uppercase tracking-wider font-semibold">Απόσταση Απότομης Ανάβασης (>5°)</div>
                    <div id="steepUphillDistance" class="font-bold text-2xl text-red-600 mt-1">--</div>
                </div>
                <div class="text-center p-3 bg-gray-50 rounded-lg">
                    <div class="text-gray-500 text-xs uppercase tracking-wider font-semibold">Θετική Υψομετρική</div>
                    <div id="elevationGain" class="font-bold text-2xl text-green-600 mt-1">--</div>
                </div>
                <div class="text-center p-3 bg-gray-50 rounded-lg">
                    <div class="text-gray-500 text-xs uppercase tracking-wider font-semibold">Αρνητική Υψομετρική</div>
                    <div id="elevationLoss" class="font-bold text-2xl text-orange-500 mt-1">--</div>
                </div>
            </div>
            <div id="no-stats-message" class="flex items-center justify-center h-full text-gray-500">
                Δημιουργήστε μια διαδρομή για να δείτε τα στατιστικά.
            </div>
        </div>
        <div id="elevation-panel" class="w-[70%] p-4 flex flex-col">
            <h2 class="text-lg font-bold mb-2 text-gray-800">Υψομετρικό Προφίλ</h2>
            <div id="elevationChartContainer" class="flex-grow relative -ml-4">
                <canvas id="elevationChart"></canvas>
                <div id="no-elevation-message" class="flex items-center justify-center h-full text-gray-500">
                    Το γράφημα θα εμφανιστεί εδώ.
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <script>
        // --- CONFIGURATION (unchanged) ---
        const CONFIG = {
            OPENROUTE_API_KEY: '5b3ce3597851110001cf6248f9179b24a16445d88b8139ff01cc3463',
            ELEVATION_API_URL: 'https://api.open-elevation.com/api/v1/lookup',
            GRAPHHOPPER_KEY: 'bf786448-12b8-4aea-8549-b3cc120e9f8c',
            MAX_PINS: 20,
            DEFAULT_CENTER: [37.9838, 23.7275],
            DEFAULT_ZOOM: 13,
            STEEP_GRADIENT_THRESHOLD: 5
        };

        // --- GLOBAL STATE (unchanged) ---
        const state = {
            map: null,
            pins: [],
            markers: [],
            routePolylines: [],
            elevationChart: null,
            currentRoute: null,
            currentElevation: { data: [], coordinates: [] },
            highlightMarker: null,
            selectedMarkerIndex: -1
        };

        // --- INITIALIZATION (unchanged, except added search listener) ---
        document.addEventListener('DOMContentLoaded', initApp);

        function initApp() {
            initMap();
            setupEventListeners();
            updateStatsVisibility(false);
            addSearchListeners();
            console.log('Εφαρμογή Σχεδιασμού Διαδρομής αρχικοποιήθηκε.');
        }

        function initMap() {
            state.map = L.map('map', {
                center: CONFIG.DEFAULT_CENTER,
                zoom: CONFIG.DEFAULT_ZOOM,
                zoomControl: true
            });
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(state.map);
            state.map.on('click', handleMapClick);
            state.map.on('contextmenu', handleMapRightClick);

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const { latitude, longitude } = position.coords;
                        state.map.setView([latitude, longitude], CONFIG.DEFAULT_ZOOM);
                    },
                    (error) => console.log('Η γεωεντοποπιση απέτυχε:', error.message),
                    { timeout: 5000 }
                );
            }
        }

        function setupEventListeners() {
            document.getElementById('clearRoute').addEventListener('click', () => clearRoute(true));
            document.getElementById('downloadGPX').addEventListener('click', downloadGPX);

            const menuToggle = document.getElementById('menuToggle');
            const menuPanel = document.getElementById('menuPanel');
            const menuIcon = document.getElementById('menuIcon');
            const closeIcon = document.getElementById('closeIcon');

            menuToggle.addEventListener('click', () => {
                const isHidden = menuPanel.classList.contains('menu-hidden');
                if (isHidden) {
                    menuPanel.classList.remove('menu-hidden');
                    menuIcon.classList.add('hidden');
                    closeIcon.classList.remove('hidden');
                } else {
                    menuPanel.classList.add('menu-hidden');
                    menuIcon.classList.remove('hidden');
                    closeIcon.classList.add('hidden');
                }
            });

            window.addEventListener('resize', () => {
                if (state.map) setTimeout(() => state.map.invalidateSize(), 100);
            });
        }

        // --- NEW: Search functionality ---
        function addSearchListeners() {
            const searchBtn = document.getElementById('searchBtn');
            const searchInput = document.getElementById('searchInput');

            const doSearch = () => {
                const query = searchInput.value.trim();
                if (!query) return;

                fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1&addressdetails=1`)
                    .then(res => res.json())
                    .then(data => {
                        if (data && data.length) {
                            const { lat, lon, display_name } = data[0];
                            state.map.setView([lat, lon], 16);
                            hideError();
                        } else {
                            showError('Δεν βρέθηκε η τοποθεσία που αναζητήσατε.');
                        }
                    })
                    .catch(() => showError('Σφάλμα κατά την αναζήτηση. Δοκιμάστε ξανά.'));
            };

            searchBtn.addEventListener('click', doSearch);
            searchInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') doSearch();
            });
        }

        // --- EVERYTHING BELOW IS UNCHANGED EXCEPT FOR MINOR CONTEXT-KEEPING TWEAKS ---

        function handleMapClick(e) {
            if (state.pins.length >= CONFIG.MAX_PINS) {
                showError(`Επιτρέπονται μέχρι ${CONFIG.MAX_PINS} σημεία.`);
                return;
            }
            const latlng = e.latlng;
            state.pins.push(latlng);
            addMarker(latlng, state.pins.length);
            if (state.pins.length >= 2) calculateRoute();
            updateInstructions();
        }

        function handleMapRightClick(e) {
            e.originalEvent.preventDefault();
            if (state.pins.length === 0) return;
            let nearestIndex = -1, minDistance = Infinity;
            state.pins.forEach((pin, index) => {
                const distance = e.latlng.distanceTo(pin);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestIndex = index;
                }
            });
            if (nearestIndex !== -1) removePin(nearestIndex);
        }

        function addMarker(latlng, number) {
            const marker = L.marker(latlng, {
                icon: createNumberedIcon(number, number === 1),
                draggable: true
            }).addTo(state.map);
            marker.on('dragend', e => {
                const index = state.markers.indexOf(marker);
                state.pins[index] = e.target.getLatLng();
                if (state.pins.length >= 2) calculateRoute();
            });
            state.markers.push(marker);
        }

        function removePin(index) {
            if (index < 0 || index >= state.pins.length) return;
            state.map.removeLayer(state.markers[index]);
            state.pins.splice(index, 1);
            state.markers.splice(index, 1);
            state.markers.forEach((marker, i) => marker.setIcon(createNumberedIcon(i + 1, i === 0)));
            if (state.pins.length >= 2) calculateRoute();
            else clearRoute(false);
            updateInstructions();
        }

        function createNumberedIcon(number, isStart = false) {
            const baseClass = 'pin-icon' + (isStart ? ' start' : '');
            return L.divIcon({
                className: baseClass,
                html: number.toString(),
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        // --- ROUTE & ELEVATION CALCULATION (unchanged) ---
        async function calculateRoute() {
            if (state.pins.length < 2) return;
            showLoading(true);
            hideError();
            try {
                let routeData = null;
                const apis = [fetchFromORS, fetchFromGraphHopper];
                for (const fetchFunc of apis) {
                    try {
                        routeData = await fetchFunc();
                        if (routeData) break;
                    } catch (error) {
                        console.warn(`${fetchFunc.name} failed:`, error.message);
                    }
                }
                if (!routeData) throw new Error('Όλες οι υπηρεσίες δρομολόγησης απέτυχαν.');
                if (routeData.coordinates.length > 0 && routeData.coordinates[0].length === 2) {
                    const elevations = await fetchElevationSeparately(routeData.coordinates);
                    routeData.coordinates.forEach((coord, index) => coord.push(elevations[index] || 0));
                }
                state.currentRoute = routeData;
                processElevationData(routeData.coordinates);
            } catch (error) {
                showError(error.message);
                console.error('Route calculation error:', error);
            } finally {
                showLoading(false);
            }
        }

        async function fetchFromORS() {
            const coordinates = state.pins.map(pin => [pin.lng, pin.lat]);
            const response = await fetch('https://api.openrouteservice.org/v2/directions/driving-car/geojson', {
                method: 'POST',
                headers: {
                    'Authorization': CONFIG.OPENROUTE_API_KEY,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ coordinates, instructions: false, elevation: true })
            });
            if (!response.ok) throw new Error(`ORS API error: ${response.status}`);
            const data = await response.json();
            if (!data.features?.[0]) throw new Error('Δεν βρέθηκε διαδρομή από το ORS');
            const route = data.features[0];
            return {
                coordinates: route.geometry.coordinates.map(c => [c[1], c[0], c[2]]),
                distance: route.properties.summary?.distance || 0
            };
        }

        async function fetchFromGraphHopper() {
            const points = state.pins.map(pin => `point=${pin.lat},${pin.lng}`).join('&');
            const url = `https://graphhopper.com/api/1/route?${points}&vehicle=car&calc_points=true&points_encoded=false&type=json&key=${CONFIG.GRAPHHOPPER_KEY}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error(`GraphHopper API error: ${response.status}`);
            const data = await response.json();
            if (!data.paths?.[0]) throw new Error('Δεν βρέθηκε διαδρομή από το GraphHopper');
            const path = data.paths[0];
            return {
                coordinates: path.points.coordinates.map(c => [c[1], c[0]]),
                distance: path.distance
            };
        }

        async function fetchElevationSeparately(coordinates) {
            const maxPoints = 300;
            let pointsToFetch = coordinates;
            if (coordinates.length > maxPoints) {
                pointsToFetch = [];
                const step = Math.floor(coordinates.length / maxPoints);
                for (let i = 0; i < coordinates.length; i += step) pointsToFetch.push(coordinates[i]);
            }
            const response = await fetch(CONFIG.ELEVATION_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ locations: pointsToFetch.map(c => ({ latitude: c[0], longitude: c[1] })) })
            });
            if (!response.ok) throw new Error('Elevation API failed');
            const data = await response.json();
            const elevations = data.results.map(r => r.elevation);
            if (coordinates.length > maxPoints) {
                const fullElevations = [];
                for (let i = 0; i < coordinates.length; i++) {
                    const step = Math.floor(coordinates.length / maxPoints);
                    const prevIndex = Math.floor(i / step);
                    const nextIndex = Math.min(prevIndex + 1, elevations.length - 1);
                    if (prevIndex === nextIndex) { fullElevations.push(elevations[prevIndex]); continue; }
                    const prevElev = elevations[prevIndex], nextElev = elevations[nextIndex];
                    const ratio = (i % step) / step;
                    fullElevations.push(prevElev + (nextElev - prevElev) * ratio);
                }
                return fullElevations;
            }
            return elevations;
        }

        function processElevationData(routeCoordinates) {
            let cumulativeDistance = 0, elevationGain = 0, elevationLoss = 0, steepUphillDistance = 0;
            const elevationProfileData = [];
            routeCoordinates.forEach((point, index) => {
                const elevation = point[2];
                if (index > 0) {
                    const prevPoint = routeCoordinates[index - 1];
                    const segmentDistance = calculateHaversineDistance(prevPoint, point);
                    cumulativeDistance += segmentDistance;
                    const elevationDiff = elevation - (prevPoint[2] || 0);
                    if (elevationDiff > 0) elevationGain += elevationDiff;
                    else elevationLoss += Math.abs(elevationDiff);
                    if (segmentDistance > 0) {
                        const gradient = Math.atan(elevationDiff / segmentDistance) * (180 / Math.PI);
                        if (gradient > CONFIG.STEEP_GRADIENT_THRESHOLD) steepUphillDistance += segmentDistance;
                    }
                }
                elevationProfileData.push({ distance: cumulativeDistance, elevation });
            });
            const maxChartPoints = 300;
            let sampledElevationData = elevationProfileData, sampledRouteCoords = routeCoordinates;
            if (elevationProfileData.length > maxChartPoints) {
                sampledElevationData = [];
                sampledRouteCoords = [];
                const step = Math.floor(elevationProfileData.length / maxChartPoints);
                for (let i = 0; i < elevationProfileData.length; i += step) {
                    sampledElevationData.push(elevationProfileData[i]);
                    sampledRouteCoords.push(routeCoordinates[i]);
                }
            }
            state.currentElevation = { data: sampledElevationData, coordinates: sampledRouteCoords };
            updateRouteStats({ distance: cumulativeDistance, elevationGain, elevationLoss, steepUphillDistance });
            displayColoredRoute(routeCoordinates);
            displayElevationChart(sampledElevationData);
            updateStatsVisibility(true);
        }

        function displayColoredRoute(routeCoordinates) {
            state.routePolylines.forEach(p => state.map.removeLayer(p));
            state.routePolylines = [];
            let currentSegment = [], isCurrentSegmentSteep = false;
            for (let i = 1; i < routeCoordinates.length; i++) {
                const startPoint = routeCoordinates[i - 1], endPoint = routeCoordinates[i];
                const segmentDistance = calculateHaversineDistance(startPoint, endPoint);
                const elevationDiff = endPoint[2] - startPoint[2];
                let isSteep = false;
                if (segmentDistance > 0) {
                    const gradient = Math.atan(elevationDiff / segmentDistance) * (180 / Math.PI);
                    if (gradient > CONFIG.STEEP_GRADIENT_THRESHOLD) isSteep = true;
                }
                if (i === 1) { currentSegment.push([startPoint[0], startPoint[1]]); isCurrentSegmentSteep = isSteep; }
                if (isSteep !== isCurrentSegmentSteep) {
                    currentSegment.push([endPoint[0], endPoint[1]]);
                    const polyline = L.polyline(currentSegment, { color: isCurrentSegmentSteep ? '#EF4444' : '#3B82F6', weight: 5, opacity: 0.85 }).addTo(state.map);
                    state.routePolylines.push(polyline);
                    currentSegment = [[endPoint[0], endPoint[1]]];
                    isCurrentSegmentSteep = isSteep;
                } else {
                    currentSegment.push([endPoint[0], endPoint[1]]);
                }
            }
            if (currentSegment.length > 1) {
                const polyline = L.polyline(currentSegment, { color: isCurrentSegmentSteep ? '#EF4444' : '#3B82F6', weight: 5, opacity: 0.85 }).addTo(state.map);
                state.routePolylines.push(polyline);
            }
            const group = new L.featureGroup([...state.routePolylines, ...state.markers]);
            state.map.fitBounds(group.getBounds(), { padding: [60, 60] });
            document.getElementById('downloadGPX').style.display = 'flex';
        }

        function updateRouteStats(data) {
            const formatDistance = d => d > 1000 ? `${(d / 1000).toFixed(2)} km` : `${Math.round(d)} m`;
            document.getElementById('totalDistance').textContent = formatDistance(data.distance);
            document.getElementById('steepUphillDistance').textContent = formatDistance(data.steepUphillDistance);
            document.getElementById('elevationGain').textContent = `+${Math.round(data.elevationGain)} m`;
            document.getElementById('elevationLoss').textContent = `-${Math.round(data.elevationLoss)} m`;
        }

        function displayElevationChart(elevationData) {
            const ctx = document.getElementById('elevationChart').getContext('2d');
            if (state.elevationChart) state.elevationChart.destroy();
            document.getElementById('no-elevation-message').style.display = 'none';
            const labels = elevationData.map(d => (d.distance / 1000).toFixed(2));
            const elevations = elevationData.map(d => d.elevation);
            state.elevationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: 'Υψόμετρο (m)',
                        data: elevations,
                        borderColor: '#3B82F6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 5,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    scales: {
                        x: { title: { display: true, text: 'Απόσταση (km)' }, ticks: { autoSkip: true, maxTicksLimit: 10 } },
                        y: { title: { display: true, text: 'Υψόμετρο (m)' } }
                    },
                    plugins: { legend: { display: false }, tooltip: { callbacks: { title: ctx => `Απόσταση: ${ctx[0].label} km`, label: ctx => `Υψόμετρο: ${Math.round(ctx.raw)} m` } } },
                    onHover: (event, chartElement) => {
                        if (chartElement.length > 0) {
                            const index = chartElement[0].index;
                            const coord = state.currentElevation.coordinates[index];
                            if (coord) {
                                const latlng = [coord[0], coord[1]];
                                if (!state.highlightMarker) {
                                    state.highlightMarker = L.circleMarker(latlng, { radius: 8, fillColor: "#F59E0B", color: "#fff", weight: 2, opacity: 1, fillOpacity: 0.9 }).addTo(state.map);
                                } else {
                                    state.highlightMarker.setLatLng(latlng);
                                }
                            }
                        } else {
                            if (state.highlightMarker) { state.map.removeLayer(state.highlightMarker); state.highlightMarker = null; }
                        }
                    }
                }
            });
        }

        // --- UTILITY FUNCTIONS (unchanged) ---
        function clearRoute(clearPins) {
            if (clearPins) {
                state.markers.forEach(marker => state.map.removeLayer(marker));
                state.markers = [];
                state.pins = [];
            }
            state.routePolylines.forEach(p => state.map.removeLayer(p));
            state.routePolylines = [];
            if (state.elevationChart) { state.elevationChart.destroy(); state.elevationChart = null; }
            if (state.highlightMarker) { state.map.removeLayer(state.highlightMarker); state.highlightMarker = null; }
            state.currentRoute = null;
            state.currentElevation = { data: [], coordinates: [] };
            updateStatsVisibility(false);
            document.getElementById('downloadGPX').style.display = 'none';
            document.getElementById('no-elevation-message').style.display = 'flex';
            updateInstructions();
            hideError();
        }

        function downloadGPX() {
            if (!state.currentRoute) { showError('Δεν υπάρχει διαδρομή για λήψη'); return; }
            const gpxContent = generateGPX(state.currentRoute);
            const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route_${new Date().toISOString().slice(0,10)}.gpx`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function generateGPX(route) {
            const timestamp = new Date().toISOString();
            let gpx = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="Route Planner" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">\n  <metadata><time>${timestamp}</time></metadata>\n  <trk><name>Planned Route</name><trkseg>`;
            route.coordinates.forEach(coord => gpx += `\n      <trkpt lat="${coord[0]}" lon="${coord[1]}"><ele>${coord[2] || 0}</ele></trkpt>`);
            gpx += `\n    </trkseg></trk></gpx>`;
            return gpx;
        }

        function calculateHaversineDistance(coords1, coords2) {
            const R = 6371e3;
            const φ1 = coords1[0] * Math.PI/180;
            const φ2 = coords2[0] * Math.PI/180;
            const Δφ = (coords2[0]-coords1[0]) * Math.PI/180;
            const Δλ = (coords2[1]-coords1[1]) * Math.PI/180;
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function showLoading(show) { document.getElementById('loadingMessage').style.display = show ? 'flex' : 'none'; }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            document.getElementById('errorText').textContent = message;
            errorEl.style.display = 'block';
            errorEl.className = errorEl.className.replace(' error-fade', '');
            setTimeout(() => { errorEl.className += ' error-fade'; }, 4000);
        }

        function hideError() { document.getElementById('errorMessage').style.display = 'none'; }

        function updateInstructions() { document.getElementById('instructions').style.display = state.pins.length === 0 ? 'block' : 'none'; }

        function updateStatsVisibility(show) {
            document.getElementById('stats-content').style.display = show ? 'block' : 'none';
            document.getElementById('no-stats-message').style.display = show ? 'none' : 'flex';
        }
    </script>
</body>
</html>