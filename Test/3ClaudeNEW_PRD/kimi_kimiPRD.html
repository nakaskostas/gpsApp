<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Planner - Elevation & Gradient Analysis</title>
    
    <!-- External Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <style>
        .leaflet-container {
            height: 100%;
            width: 100%;
            cursor: crosshair;
        }
        
        .pin-marker {
            background: #3B82F6;
            border: 3px solid white;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
        }
        
        .pin-marker.start {
            background: #10B981;
        }
        
        .pin-marker.selected {
            border-color: #FFC107;
            border-width: 4px;
        }
        
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3B82F6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-fade {
            animation: fadeOut 5s forwards;
        }
        
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; display: none; }
        }
        
        .gradient-segment {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden flex flex-col">
    
    <!-- Header -->
    <header class="bg-white shadow-sm p-4 flex justify-between items-center">
        <h1 class="text-xl font-bold flex items-center gap-2">
            <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
            </svg>
            Route Planner with Elevation
        </h1>
        <div class="flex gap-2">
            <button id="clearRoute" class="flex items-center gap-2 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                </svg>
                Clear Route
            </button>
            <button id="downloadGPX" class="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors" style="display: none;">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                Download GPX
            </button>
        </div>
    </header>

    <!-- Error/Loading Messages -->
    <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 mx-4 mt-2 rounded relative" style="display: none;">
        <span id="errorText"></span>
    </div>
    
    <div id="loadingMessage" class="fixed top-20 left-1/2 transform -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded shadow-lg z-50 flex items-center gap-2" style="display: none;">
        <div class="loading-spinner"></div>
        <span>Calculating route...</span>
    </div>

    <!-- Main Content -->
    <div class="flex-1 flex flex-col md:flex-row">
        <!-- Map Container -->
        <div class="flex-1 relative" style="height: 60vh;">
            <div id="map" class="h-full w-full"></div>
            <div id="instructions" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-blue-50 border border-blue-200 px-4 py-2 rounded shadow-lg">
                <p class="text-blue-700 text-sm">
                    Click on the map to place pins and create your route. Right-click to remove pins.
                </p>
            </div>
        </div>

        <!-- Stats & Elevation Panel -->
        <div id="elevationSection" class="bg-white border-t md:border-t-0 md:border-l md:w-96" style="display: none;">
            <!-- Route Statistics -->
            <div class="p-4 border-b">
                <h3 class="text-lg font-semibold mb-3">Route Statistics</h3>
                <div class="space-y-3">
                    <div>
                        <div class="text-gray-600 text-xs uppercase tracking-wide">Total Distance</div>
                        <div id="totalDistance" class="font-bold text-xl text-blue-600">-</div>
                    </div>
                    <div>
                        <div class="text-gray-600 text-xs uppercase tracking-wide">Uphill Distance (>5°)</div>
                        <div id="uphillDistance" class="font-bold text-lg text-red-600">-</div>
                    </div>
                    <div>
                        <div class="text-gray-600 text-xs uppercase tracking-wide">Elevation Gain</div>
                        <div id="elevationGain" class="font-bold text-lg text-green-600">-</div>
                    </div>
                    <div>
                        <div class="text-gray-600 text-xs uppercase tracking-wide">Elevation Loss</div>
                        <div id="elevationLoss" class="font-bold text-lg text-red-600">-</div>
                    </div>
                </div>
            </div>
            
            <!-- Elevation Chart -->
            <div class="p-4" style="height: 300px;">
                <canvas id="elevationChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            OPENROUTE_API_KEY: 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImY5MTc5YjI0YTE2NDQ1ZDg4YjgxMzlmZjAxY2MzNDYzIiwiaCI6Im11cm11cjY0In0=',
            GRAPHHOPPER_KEY: 'bf786448-12b8-4aea-8549-b3cc120e9f8c',
            ELEVATION_API_URL: 'https://api.open-elevation.com/api/v1/lookup',
            MAX_PINS: 20,
            STEEP_THRESHOLD: 5,
            DEFAULT_CENTER: [37.9755, 23.7348], // Athens
            DEFAULT_ZOOM: 13
        };

        // Global state
        const state = {
            map: null,
            pins: [],
            markers: [],
            routePolyline: null,
            elevationChart: null,
            currentRoute: null,
            selectedPin: null
        };

        // Initialize app
        function initApp() {
            initMap();
            setupEventListeners();
            console.log('Route Planner initialized');
        }

        // Initialize map
        function initMap() {
            state.map = L.map('map', {
                center: CONFIG.DEFAULT_CENTER,
                zoom: CONFIG.DEFAULT_ZOOM,
                zoomControl: true
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(state.map);

            state.map.on('click', handleMapClick);
            state.map.on('contextmenu', handleMapRightClick);

            // Try to get user location
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const { latitude, longitude } = position.coords;
                        state.map.setView([latitude, longitude], CONFIG.DEFAULT_ZOOM);
                    },
                    (error) => console.log('Geolocation failed:', error),
                    { timeout: 5000 }
                );
            }
        }

        // Event listeners
        function setupEventListeners() {
            document.getElementById('clearRoute').addEventListener('click', clearRoute);
            document.getElementById('downloadGPX').addEventListener('click', downloadGPX);
        }

        // Handle map click
        function handleMapClick(e) {
            if (state.pins.length >= CONFIG.MAX_PINS) {
                showError(`Maximum ${CONFIG.MAX_PINS} pins allowed`);
                return;
            }

            const latlng = e.latlng;
            state.pins.push(latlng);
            addMarker(latlng, state.pins.length);
            
            if (state.pins.length >= 2) {
                calculateRoute();
            }
            updateInstructions();
        }

        // Handle right click for pin removal
        function handleMapRightClick(e) {
            e.originalEvent.preventDefault();
            
            let nearestIndex = -1;
            let minDistance = Infinity;

            state.pins.forEach((pin, index) => {
                const distance = e.latlng.distanceTo(pin);
                if (distance < minDistance && distance < 100) {
                    minDistance = distance;
                    nearestIndex = index;
                }
            });

            if (nearestIndex !== -1) {
                removePin(nearestIndex);
            }
        }

        // Add marker to map
        function addMarker(latlng, number) {
            const marker = L.marker(latlng, {
                icon: createMarkerIcon(number),
                draggable: true
            }).addTo(state.map);

            marker.on('dragend', (e) => {
                const index = state.markers.indexOf(marker);
                state.pins[index] = e.target.getLatLng();
                if (state.pins.length >= 2) {
                    calculateRoute();
                }
            });

            marker.on('click', () => {
                const index = state.markers.indexOf(marker);
                selectPin(index);
            });

            state.markers.push(marker);
        }

        // Create marker icon
        function createMarkerIcon(number) {
            const className = number === 1 ? 'pin-marker start' : 'pin-marker';
            return L.divIcon({
                className: className,
                html: number.toString(),
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
        }

        // Select pin
        function selectPin(index) {
            state.markers.forEach((marker, i) => {
                const className = i === index ? 'pin-marker selected' : 
                                (i === 0 ? 'pin-marker start' : 'pin-marker');
                marker.setIcon(L.divIcon({
                    className: className,
                    html: (i + 1).toString(),
                    iconSize: [32, 32],
                    iconAnchor: [16, 16]
                }));
            });
        }

        // Remove pin
        function removePin(index) {
            state.map.removeLayer(state.markers[index]);
            state.pins.splice(index, 1);
            state.markers.splice(index, 1);

            // Update marker numbers
            state.markers.forEach((marker, i) => {
                marker.setIcon(createMarkerIcon(i + 1));
            });

            if (state.pins.length >= 2) {
                calculateRoute();
            } else {
                clearRoute(false);
            }
            updateInstructions();
        }

        // Calculate route with fallbacks
        async function calculateRoute() {
            if (state.pins.length < 2) return;

            showLoading(true);
            hideError();

            try {
                let routeData = null;
                const apis = [
                    calculateRouteOpenRoute,
                    calculateRouteGraphHopper,
                    calculateRouteOSRM
                ];

                for (const api of apis) {
                    try {
                        routeData = await api();
                        break;
                    } catch (error) {
                        console.log(`${api.name} failed:`, error.message);
                    }
                }

                if (!routeData) throw new Error('All routing services failed');

                state.currentRoute = routeData;
                displayRoute(routeData);
                await calculateElevation(routeData);

            } catch (error) {
                showError('Failed to calculate route. Please try again.');
            } finally {
                showLoading(false);
            }
        }

        // OpenRouteService API
        async function calculateRouteOpenRoute() {
            const coordinates = state.pins.map(pin => [pin.lng, pin.lat]);
            const response = await fetch('https://api.openrouteservice.org/v2/directions/driving-car/geojson', {
                method: 'POST',
                headers: {
                    'Authorization': CONFIG.OPENROUTE_API_KEY,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    coordinates: coordinates,
                    instructions: false,
                    elevation: false
                })
            });

            if (!response.ok) throw new Error('OpenRouteService API error');
            
            const data = await response.json();
            const route = data.features[0];
            
            return {
                coordinates: route.geometry.coordinates.map(coord => [coord[1], coord[0]]),
                distance: route.properties.summary.distance
            };
        }

        // GraphHopper API
        async function calculateRouteGraphHopper() {
            const points = state.pins.map(pin => `point=${pin.lat},${pin.lng}`).join('&');
            const url = `https://graphhopper.com/api/1/route?${points}&vehicle=car&calc_points=true&type=json&key=${CONFIG.GRAPHHOPPER_KEY}`;
            
            const response = await fetch(url);
            if (!response.ok) throw new Error('GraphHopper API error');
            
            const data = await response.json();
            const path = data.paths[0];
            
            return {
                coordinates: decodePolyline(path.points),
                distance: path.distance
            };
        }

        // OSRM API (fallback)
        async function calculateRouteOSRM() {
            const coordinates = state.pins.map(pin => `${pin.lng},${pin.lat}`).join(';');
            const url = `https://router.project-osrm.org/route/v1/driving/${coordinates}?overview=full&geometries=geojson`;
            
            const response = await fetch(url);
            if (!response.ok) throw new Error('OSRM API error');
            
            const data = await response.json();
            const route = data.routes[0];
            
            return {
                coordinates: route.geometry.coordinates.map(coord => [coord[1], coord[0]]),
                distance: route.distance
            };
        }

        // Decode polyline
        function decodePolyline(str) {
            let index = 0, lat = 0, lng = 0;
            const coordinates = [];
            
            while (index < str.length) {
                let byte, shift = 0, result = 0;
                do {
                    byte = str.charCodeAt(index++) - 63;
                    result |= (byte & 0x1f) << shift;
                    shift += 5;
                } while (byte >= 0x20);
                
                const deltaLat = ((result & 1) ? ~(result >> 1) : (result >> 1));
                lat += deltaLat;
                
                shift = 0; result = 0;
                do {
                    byte = str.charCodeAt(index++) - 63;
                    result |= (byte & 0x1f) << shift;
                    shift += 5;
                } while (byte >= 0x20);
                
                const deltaLng = ((result & 1) ? ~(result >> 1) : (result >> 1));
                lng += deltaLng;
                
                coordinates.push([lat * 1e-5, lng * 1e-5]);
            }
            
            return coordinates;
        }

        // Display route
        function displayRoute(route) {
            if (state.routePolyline) {
                state.map.removeLayer(state.routePolyline);
            }

            state.routePolyline = L.polyline(route.coordinates, {
                color: '#3B82F6',
                weight: 4,
                opacity: 0.8
            }).addTo(state.map);

            const group = new L.featureGroup([state.routePolyline, ...state.markers]);
            state.map.fitBounds(group.getBounds(), { padding: [20, 20] });

            document.getElementById('downloadGPX').style.display = 'flex';
            showElevationSection(true);
        }

        // Calculate elevation
        async function calculateElevation(route) {
            try {
                const maxPoints = 50;
                const step = Math.max(1, Math.floor(route.coordinates.length / maxPoints));
                const samplePoints = route.coordinates.filter((_, index) => index % step === 0);
                
                const response = await fetch(CONFIG.ELEVATION_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        locations: samplePoints.map(coord => ({
                            latitude: coord[0],
                            longitude: coord[1]
                        }))
                    })
                });

                const data = await response.json();
                if (data.results) {
                    processElevationData(data.results, samplePoints, route);
                }
            } catch (error) {
                console.log('Elevation API failed, using mock data');
                createMockElevation(route);
            }
        }

        // Process elevation data
        function processElevationData(elevationResults, coordinates, route) {
            let cumulativeDistance = 0;
            const elevationData = [];
            let uphillDistance = 0;

            elevationResults.forEach((point, index) => {
                if (index > 0) {
                    const prevCoord = coordinates[index - 1];
                    const currCoord = coordinates[index];
                    const segmentDistance = calculateDistance(
                        prevCoord[0], prevCoord[1],
                        currCoord[0], currCoord[1]
                    );
                    cumulativeDistance += segmentDistance;
                }

                let gradient = 0;
                if (index > 0) {
                    const elevationDiff = point.elevation - elevationResults[index - 1].elevation;
                    const distanceDiff = cumulativeDistance - (elevationData[index - 1]?.distance || 0);
                    if (distanceDiff > 0) {
                        gradient = Math.atan(elevationDiff / distanceDiff) * 180 / Math.PI;
                    }
                }

                if (gradient > CONFIG.STEEP_THRESHOLD) {
                    uphillDistance += cumulativeDistance - (elevationData[index - 1]?.distance || 0);
                }

                elevationData.push({
                    distance: cumulativeDistance,
                    elevation: point.elevation,
                    gradient: Math.abs(gradient),
                    isSteep: gradient > CONFIG.STEEP_THRESHOLD
                });
            });

            updateRouteStats(route.distance, elevationData, uphillDistance);
            displayColoredRoute(route, elevationData, coordinates);
            displayElevationChart(elevationData);
        }

        // Create mock elevation data
        function createMockElevation(route) {
            const mockPoints = 25;
            const step = Math.max(1, Math.floor(route.coordinates.length / mockPoints));
            const samplePoints = route.coordinates.filter((_, index) => index % step === 0);
            
            const mockData = samplePoints.map((coord, index) => ({
                elevation: 100 + Math.sin(index * 0.5) * 50 + Math.random() * 20
            }));

            processElevationData(mockData, samplePoints, route);
        }

        // Display colored route based on gradient
        function displayColoredRoute(route, elevationData, elevationCoords) {
            if (state.routePolyline) {
                state.map.removeLayer(state.routePolyline);
            }

            // Create segments based on steepness
            const segments = [];
            let currentSegment = [];
            let currentSteep = false;

            route.coordinates.forEach((coord, index) => {
                // Find corresponding elevation data
                let isSteep = false;
                for (let i = 0; i < elevationCoords.length - 1; i++) {
                    if (index >= i * Math.floor(route.coordinates.length / elevationCoords.length) && 
                        index < (i + 1) * Math.floor(route.coordinates.length / elevationCoords.length)) {
                        isSteep = elevationData[i]?.isSteep || false;
                        break;
                    }
                }

                if (currentSegment.length === 0 || isSteep === currentSteep) {
                    currentSegment.push(coord);
                } else {
                    segments.push({ coords: [...currentSegment], steep: currentSteep });
                    currentSegment = [coord];
                    currentSteep = isSteep;
                }
            });

            if (currentSegment.length > 0) {
                segments.push({ coords: currentSegment, steep: currentSteep });
            }

            // Draw colored segments
            state.routePolyline = segments.map(segment => 
                L.polyline(segment.coords, {
                    color: segment.steep ? '#EF4444' : '#3B82F6',
                    weight: 4,
                    opacity: 0.8
                }).addTo(state.map)
            );
        }

        // Calculate distance between coordinates
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                     Math.cos(φ1) * Math.cos(φ2) *
                     Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // Update route statistics
        function updateRouteStats(distance, elevationData, uphillDistance = 0) {
            const distanceFormatted = distance > 1000 
                ? `${(distance / 1000).toFixed(1)} km`
                : `${Math.round(distance)} m`;

            let elevationGain = 0;
            let elevationLoss = 0;

            if (elevationData) {
                for (let i = 1; i < elevationData.length; i++) {
                    const diff = elevationData[i].elevation - elevationData[i - 1].elevation;
                    if (diff > 0) elevationGain += diff;
                    else elevationLoss += Math.abs(diff);
                }
            }

            document.getElementById('totalDistance').textContent = distanceFormatted;
            document.getElementById('uphillDistance').textContent = 
                uphillDistance > 1000 
                    ? `${(uphillDistance / 1000).toFixed(1)} km`
                    : `${Math.round(uphillDistance)} m`;
            document.getElementById('elevationGain').textContent = `+${Math.round(elevationGain)} m`;
            document.getElementById('elevationLoss').textContent = `-${Math.round(elevationLoss)} m`;
        }

        // Display elevation chart
        function displayElevationChart(elevationData) {
            const ctx = document.getElementById('elevationChart').getContext('2d');
            
            if (state.elevationChart) {
                state.elevationChart.destroy();
            }

            const distances = elevationData.map(d => d.distance > 1000 
                ? (d.distance / 1000).toFixed(1) 
                : Math.round(d.distance));
            const elevations = elevationData.map(d => d.elevation);
            const backgroundColors = elevationData.map(d => 
                d.isSteep ? 'rgba(239, 68, 68, 0.3)' : 'rgba(59, 130, 246, 0.3)'
            );

            state.elevationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: distances,
                    datasets: [{
                        label: 'Elevation',
                        data: elevations,
                        borderColor: '#3B82F6',
                        backgroundColor: backgroundColors,
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    scales: {
                        x: {
                            title: { 
                                display: true, 
                                text: `Distance (${elevationData[0]?.distance > 1000 ? 'km' : 'm'})` 
                            }
                        },
                        y: {
                            title: { display: true, text: 'Elevation (m)' }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                title: (context) => {
                                    const point = elevationData[context[0].dataIndex];
                                    return `Distance: ${point.distance > 1000 ? 
                                        `${(point.distance / 1000).toFixed(1)} km` : 
                                        `${Math.round(point.distance)} m`}`;
                                },
                                label: (context) => {
                                    const point = elevationData[context.dataIndex];
                                    return [
                                        `Elevation: ${Math.round(point.elevation)}m`,
                                        `Gradient: ${point.gradient.toFixed(1)}°`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }

        // Clear route
        function clearRoute(clearPins = true) {
            if (clearPins) {
                state.markers.forEach(marker => state.map.removeLayer(marker));
                state.markers = [];
                state.pins = [];
            }

            if (state.routePolyline) {
                if (Array.isArray(state.routePolyline)) {
                    state.routePolyline.forEach(polyline => state.map.removeLayer(polyline));
                } else {
                    state.map.removeLayer(state.routePolyline);
                }
                state.routePolyline = null;
            }

            if (state.elevationChart) {
                state.elevationChart.destroy();
                state.elevationChart = null;
            }

            state.currentRoute = null;
            showElevationSection(false);
            document.getElementById('downloadGPX').style.display = 'none';
            updateInstructions();
        }

        // Download GPX
        function downloadGPX() {
            if (!state.currentRoute) {
                showError('No route to download');
                return;
            }

            const timestamp = new Date().toISOString();
            let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Route Planner" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>Planned Route</name>
    <time>${timestamp}</time>
  </metadata>
  <trk>
    <name>Route</name>
    <trkseg>`;

            state.currentRoute.coordinates.forEach(coord => {
                gpx += `\n      <trkpt lat="${coord[0]}" lon="${coord[1]}"></trkpt>`;
            });

            gpx += `
    </trkseg>
  </trk>`;

            state.pins.forEach((pin, index) => {
                gpx += `\n  <wpt lat="${pin.lat}" lon="${pin.lng}">
    <name>${index === 0 ? 'Start' : `Waypoint ${index}`}</name>
  </wpt>`;
            });

            gpx += '\n</gpx>';

            const blob = new Blob([gpx], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route_${new Date().toISOString().split('T')[0]}.gpx`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // UI Helpers
        function showElevationSection(show) {
            document.getElementById('elevationSection').style.display = show ? 'block' : 'none';
        }

        function updateInstructions() {
            document.getElementById('instructions').style.display = 
                state.pins.length === 0 ? 'block' : 'none';
        }

        function showLoading(show) {
            document.getElementById('loadingMessage').style.display = show ? 'flex' : 'none';
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorText');
            errorText.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => errorEl.style.display = 'none', 5000);
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', initApp);
        window.addEventListener('resize', () => state.map?.invalidateSize());
    </script>
</body>
</html>